[{"title":"Windows消息结构","url":"/2019/04/13/Windows消息结构/","content":"\n　Windows系统以消息为基础(message based)，以事件为驱动(event driven)，Windows应用程序的进行依靠发生的事件来驱动，事件最终会以消息的形式通知应用程序，因此Windows的消息结构体MSG是Windows系统中最基本、也是最重要的核心之一\n\n### Windows消息结构\n\n　Windows的消息结构体MSG完成声明如下(可查阅MSDN)：\n\n```\ntypedef struct tagMSG\n{\n　HWND hwnd;\n　UNIT message;\n　WPARAM wParam;\n　LPARAM lParam;\n　DWORD time;\n　POINT point;\n} MSG;\n```\n\n- HWND hwnd：表示接受该消息的窗口句柄\n\n- UNIT message：表示消息标识符(消息值)，message是MSG结构体中最重要的成员，也是MSG结构体的核心\n\n\t所有窗口消息定义为具有指定值的宏，用 `WM_` 作为前缀，前缀之后是描述消息名，比如窗口重新确定尺寸的消息值为 `WM_SIZE(0x0005)`\n\n- WPARAM wParam & LPARAM lParam：都是32位的特定附加信息，wParam和lParam的确切含义取决于message消息值，message消息值不同，wParam和lParam表示的附加信息也就不同\n\n\twParam和lParam这两个成员的命名方式是Win16系统时代遗留下来的产物，在Win16 API中WndProc()有两个参数：一个是WORD类型的16位整型变量，另一个是LONG类型的32位整型变量，根据匈牙利命名法，16位的变量就被命名为wParam, 32位的变量就被命名为lParam，到了Win32系统时代中，原来的16位变量也被扩展为32位，因此现在wParam和lParam的大小完全相同\n\n- DWORD time：表示消息送至消息队列的时间\n\n- POINT point：表示消息发送时鼠标在屏幕坐标系中的位置，POINT为嵌套结构成员，他的定义如下：\n```\ntypedef struct tagPOINT\n{\n　LONG x;\n　LONG y;\n} POINT;\n```\n\n### Windows消息分类\n\n　以 `WM_USER` 和 `WM_APP` 两个预定义的宏为界，Windows消息范围可以分为以下几类：\n```\n#define WM_USER  0x0400 \n#define WM_APP  0x8000\n```\n\n- 系统预留消息( Messages reserved for use by the system )\n\n\t消息范围：0 ~ WM_USER – 1\n\n- 自定义窗口类消息( Integer messages for use by private window classes  )\n\n\t消息范围：WM_USER ~ WM_APP – 1\n\n- 应用程序自定义消息( Messages available for use by applications )\n\n\t消息范围：WM_APP ~ 0xBFFF\n\t\n- 应用程序字符串消息( String messages for use by applications )\n\n\t消息范围：0xC000 ~ 0xFFFF\n\t\n- 系统预留( Reserved by the system  )\n\n\t消息范围：0xFFFF ~\n\n### 常用Windows消息表\n\n- WM_CREATE( 0x0001 ): 创建一个窗口\n\n- WM_DESTROY( 0x0002 ): 销毁一个窗口\n\n- WM_SIZE( 0x0005 ): 改变一个窗口的大小\n\n- WM_PAINT( 0x000F ): 要求一个窗口重画自己\n\n- WM_NOTIFY( 0x004E ): 当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口\n\n- WM_KEYDOWN( 0x0100 ): 按下一个键\n\n- WM_KEYUP( 0x0101 ): 释放一个键\n\n- WM_COMMAND( 0x0111 ): 当用户选择一条菜单命令项或当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口\n\n- WM_TIMER( 0x0113 ): 发生了定时器事件\n\n- WM_HSCROLL( 0x0114 ): 当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件\n\n- WM_VSCROLL( 0x0115 ): 当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件\n\n- WM_MOUSEMOVE( 0x0200 ): 移动鼠标\n\n- WM_LBUTTONDOWN( 0x0201 ): 按下鼠标左键\n\n- WM_LBUTTONUP( 0x0202 ): 释放鼠标左键\n\n- WM_LBUTTONDBLCLK( 0x0203 ): 双击鼠标左键\n\n- WM_RBUTTONDOWN( 0x0204 ): 按下鼠标右键\n\n- WM_RBUTTONUP( 0x0205 ): 释放鼠标右键\n\n- WM_RBUTTONDBLCLK( 0x0206 ): 双击鼠标右键\n\n\n","tags":["Windows编程"]},{"title":"C++多态的原理和实现","url":"/2019/04/13/C++多态的原理和实现/","content":"\n　多态（polymorphism）源自希腊语，从字面上理解就是多种形态，多种形式，具体到C++这种面向对象（OOP）的语言中，其实就是“一种接口，多种实现（方法）”，是C++最重要的核心特性之一\n\n### 什么是多态？\n\n　C++中多态并不仅仅是单一的一种技术，而是多种技术的合称，多态可分为**静态多态**和**动态多态**，具体的分类情况如下：\n\n![](/img/C++/Polymorphism.png)\n\n　**静态多态**和**动态多态**的关键区别是函数实现和函数调用关联起来的时间点，是在编译时期还是运行时期，也就是函数地址是**早绑定**还是**晚绑定**\n\n- **静态多态**是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是**早绑定**，静态多态也往往被叫做**静态联编**，通过**泛型编程**和**函数重载**两种方式都可以实现静态多态\n\n```\n// 泛型编程(函数模板)\ntemplate <typename T>   // typename也可以替换为class\nT add(T a, T b)\n{\n　return a + b;\n}\n```\n\n```\n// 函数重载\nint add(int a, int b)\n{\n　return a + b;\n}\n\ndouble add(double a, double b)\n{\n　return a + b;\n}\n```\n\n- **动态多态**则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于**晚绑定**，动态多态也往往被叫做**动态联编**\n\n　静态多态的原理与实现比较容易理解，下面主要讨论动态多态的原理与实现\n\n### 为什么要使用多态？\n\n　C++有封装、继承、多态三大特性，封装可以使得代码模块化，继承可以在原有的代码基础上扩展，继承是为了代码重用，而多态是为了接口重用，不论传递过来的究竟是哪个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法\n\n- 首先看一段代码：\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　\n　b.fun();   // 调用基类的fun(),打印Base::fun()\n　d.fun();   // 子类继承了基类的fun()且子类本身没有fun(),因此此处还是调用基类的fun(),打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 在子类中重定义(隐藏)fun()函数，再看这段代码：\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　\n　b.fun();   // 调用基类的fun(),打印Base::fun()\n　// 子类虽然继承了基类的fun(),但是子类本身中fun()\n　// 此时构成了重定义,基类中的fun()被隐藏，调用的是子类的fun()\n　// 打印Derived::fun()\n　d.fun();\n　d.Base::fun();   // 加类的作用域限定符,调用基类的fun(),打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 保持上面这段代码的类定义不变，用类指针类调用成员函数，分析执行结果发现，基类指针指向子类，却调用基类自己的fun函数打印Base::fun()，而不是子类的Derived::fun()，这就是因为上面讲的静态联编，其实在编译时期就将函数实现和函数调用关联起来，指针在编译时期是Base类的，自然调用Base类的fun()\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　Base *pb = &b;\n　Derived *pd = &d;\n　\n　pb->fun();   // pb指向基类,打印Base::fun()\n　pd->fun();   // pb指向子类,打印Derived::fun()\n　\n　pb = &d;   // 将基类指针指向子类\n　pb->fun();   // pb指向子类,却打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 为了避免上一段代码中的这种情况，C++中引入了动态多态，通过**继承**和**虚函数**来实现，在程序运行期间(非编译期)判断所指针指向对象的实际类型，根据其实际类型调用相应的方法，具体格式就是使用**virtual关键字**修饰类的成员函数，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定，以下为用虚函数实现的代码\n\n```\nclass Base\n{\npublic:\n　virtual void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　Base *pb = &b;\n　Derived *pd = &d;\n　\n　pb->fun();   // pb指向基类,打印Base::fun()\n　pd->fun();   // pb指向子类,打印Derived::fun()\n　\n　pb = &d;   // 将基类指针指向子类\n　pb->fun();   // pb实际指向子类,打印Derived::fun()\n　\n　return 0;\n}\n```\n\n　动态多态的实现有两个必要的绑定条件：\n\n- 必须在基类中定义虚函数\n- 必须通过基类类型的引用或者指针调用虚函数\n\n### 多态怎么实现？\n\n　C++通过继承和虚函数来实现多态，编译器在编译的时候，会为每个包含虚函数的类创建一个虚表(vtable)，在虚表中存放每个虚函数的地址，编译器另外还为每个对象提供了一个虚表指针(vptr)，这个指针指向了对象所属类的vtable，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的vtable，从而在调用虚函数的时候，能够找到正确的函数\n\n![](/img/C++/vtable.png)\n\n　由于每个对象调用的虚函数都是通过vptr来索引的，因此vptr的正确初始化是非常重要的，在vptr没有正确初始化之前，不能够去调用虚函数，C++在类的构造函数中进行vtable的创建和vptr的初始化，在构造子类对象时，要先调用父类的构造函数，初始化父类对象的vptr，此时vptr指向父类的vtbale，当执行子类的构造函数时，子类对象的vptr被初始化，指向子类的vtbale\n\n\n","tags":["C++"]},{"title":"单例(Singleton)模式","url":"/2019/04/12/单例(Singleton)模式/","content":"\n　对于具有一定开发经验的程序员，几乎都在项目中使用或者接触过单例模式，单例模式是软件设计模式中最常用的模式之一\n\n　在计算机系统中，线程池、缓存、日志对象、打印机、显卡的驱动程序对象等常被设计成单例实现，这些应用都或多或少具有资源管理器的功能，比如每台计算机一定只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中，选择单例模式就是为了避免不一致状态，避免发生冲突\n\n### 单例模式的定义\n\n　单例模式涉及到一个单一的类(单例类)，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象，可以概括为以下三点：\n\n- 单例类只能有一个实例\n\n- 单例类必须自己创建自己的唯一实例\n\n- 单例类必须给所有其他对象提供这一实例的访问方式\n\n![](/img/DesignPattern/Singleton.jpg)\n\n### 单例模式的代码实现(C++)\n\n　单例模式有两种实现方式 —— 懒汉方式和饿汉方式：　\n\n- 懒汉方式：在第一次用到类实例的时候才会去实例化，访问线程比较少时，可使用懒汉方式，用时间换空间\n\n```\n// 单例模式的懒汉方式实现\n// 为了保证线程安全，需要加锁\n\nclass Singleton\n{\nprotected:\n　Singleton();\npublic:\n　static pthread_mutex_t mutex;\n　static Singleton* GetInstance();\nprivate:\n　static Singleton* p;\n}\n\npthread_mutex_t Singleton::mutex;\nSingleton* Singleton::p = NULL;\n\nSingleton::Singleton()\n{\n　pthread_mutex_init(&mutex);\n}\n\nSingleton* Singleton::GetInstance()\n{\n　if( p == NULL)\n　{\n　　pthread_mutex_lock(&mutex);\n　　p = new Singleton();\n　　pthread_mutex_lock(&mutex);\n　}\n　\n　return p;\n}\n\n```\n\n- 饿汉方式：单例类定义的时候就进行实例化，访问线程比较多时，可使用饿汉方式，用空间换时间\n\n```\n// 单例模式的饿汉方式实现\n// 饿汉方式本身就是线程安全的\n\nclass Singleton\n{\nprotected:\n　Singleton() {}\npublic:\n　static Singleton* GetInstance();\nprivate:\n　static Singleton* p;\n}\n\nSingleton* Singleton::p = Singleton();\n\nSingleton* Singleton::GetInstance()\n{\n　return p;\n}\n\n```\n\n\n\n","tags":["设计模式"]},{"title":"C++关键字用法总结","url":"/2019/04/12/C++关键字用法总结/","content":"\n### 关键字extern\n\n　C++支持分离式编译机制，一个完整的程序或项目可以分割为若干个.cpp源文件，每个.cpp源文件单独编译生成.obj目标文件，最后将所有.obj目标文件链接成一个单一的可执行文件，如果一个.cpp源文件要使用另一个.cpp源文件定义的变量，应该如何调用？\n　**C++中解决方法是将 `变量声明` 与 `变量定义` 分离**\n\n　`变量声明` 规定了变量的类型和名字，但仅仅只是告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存，使得名字为本程序文件所知道，比如一个文件如果想使用在另外一个文件中定义的变量，则必须包含对那个变量名字的声明，关键字extern就被用来实现 `变量声明`\n\n　`变量定义` 同样规定了变量的类型和名字，不同于 `变量声明` 的是，`变量定义` 还会给变量申请存储空间，还可能给变量赋予一个初始值，如果多个文件中都定义了同一个变量，编译时会产生变量重定义冲突错误\n\n\t```\n\textern int i;   // 变量声明\n\tint j;   // 变量定义\n\t\n\t// 需要注意!\n\t// 任何一个显式初始化的声明都将成为定义，而不管有没有extern\n\textern double pi = 3.1415926;\n\t```\n\n　关键字extern主要有以下三种使用方法：\n\n- 引用同一个文件中的变量\n\n```\n#include <stdio.h>\n\nint func();\n\nint main()\n{\n　func();\n　extern int num;   // 引用同一个文件中的变量\n　printf(\"%d\", num);\n　\n　return 0;\n}\n\nint num = 3;\n\nint func()\n{\n　printf(\"%d\\n\",num);\n}\n```\n\n- 引用另一个文件中的变量\n\n```\n// main.cpp\n\n#include <stdio.h>\n\nint main()\n{\n　extern int num;   // 引用另一个文件中的变量\n　printf(\"%d\",num);\n　\n　return 0;\n}\n```\n\n```\n// branch.cpp\n\n#include <stdio.h>\n\nint num = 5;\n```\n\n- 引用另一个文件中的函数\n\n```\n// main.cpp\n\n#include <stdio.h>\n\nint main()\n{\n　extern void func();   // 引用另一个文件中的函数\n　func();\n　\n　return 0;\n}\n```\n\n```\n// branch.cpp\n\n#include <stdio.h>\n\nvoid func()\n{\n　printf(\"func\");\n}\n```\n\n### 关键字const\n\n- const定义的常量，不能被修改；\n\n```\nconst int a;\n```\n\n- const修饰函数参数，防止被意外修改；\n\n```\nvoid func(const int a);\n```\n\n- const修饰函数返回值，则返回值不能被直接修改，且只能赋值给const修饰的同类变量；\n\n```\nconst int x = const int func(const int a);\n```\n\n- const修饰类成员变量，只能在定义的时候进行初始化，并且在程序的执行过程中不能被再次赋值；\n\n- const修饰类成员函数，放在类成员函数声明之后，保证不会修改该对象的成员变量\n\n```\nvoid fun(int val) const;\n// 任何不会修改类成员变量的类成员函数都应该使用const修饰\n// const成员函数不能调用非const成员函数\n```\n\n### 关键字static（面向过程）\n\n　关键字static的作用主要可以分为两方面，一方面是面向过程，另一方面是面向对象，先介绍面向过程：\n\n- **静态全局变量**\n\n　在全局变量前加上关键字static，该变量就被定义为静态全局变量，静态全局变量在全局/静态存储区初始化，作用域仅限于定义的文件，具有内部链接性\n\n- **静态局部变量**\n\n　在代码块中定义的变量前加上关键字static，该变量就被定义为静态局部变量，他始终驻留在全局/静态存储区，直到程序运行结束\n\n- **静态函数**\n\n　静态函数的声明方法也是在函数前加上关键字static，作用域仅限于定义的文件，不能被其他文件引用，不会发生冲突\n\n### 关键字static（面向对象）\n\n- **静态成员变量**\n\n　对于非静态成员变量，每个类对象都有自己的拷贝，而静态成员变量只有一份拷贝，存在于全局/静态存储区，由该类型的所有对象共享，静态成员变量定义时要分配空间，所以不能在类声明中定义，只能在类外定义\n\n- **静态成员函数**\n\n　普通成员函数一般都隐藏了一个this指针，this指针指向类对象本身，因为普通成员函数总是具体的属于某个类的具体对象的，而静态成员函数不具有this指针，因此他无法访问属于类对象的非静态成员变量，也无法访问非静态成员函数\n\n　一切不需要实例化就可以有确定行为方式的函数都应该设计成静态的，比如封装一些算法，或者实现一些设计模式\n\n### 关键字virtual\n\n 类的多态特性是支持面向对象的语言最主要的特性，C++中的关键字virtual是实现多态的重要方式\n\n- 虚函数\n　虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数\n\n- 纯虚函数\n　在基类中不对虚函数给出实现，把它声明为纯虚函数，它的实现留给该基类的派生类去完成，含有纯虚函数的类构成抽象类\n\n- 虚继承\n　在派生类继承基类时，加上一个virtual关键词则为虚拟基类继承，虚继承主要用于一个类继承多个类的情况，避免重复继承同一个类两次或多次\n\n### 关键字struct\n\n　在C语言中，struct用来定义一个结构体，仅仅是一个包含不同数据类型的数据结构，C++中的struct对C语言中的struct进行了扩充，C++中的struct结构体能包含成员函数，能继承，也能实现多态，其实已经几乎实现了class的功能，在C++中struct和class的区别主要是以下两点\n\n- struct的默认的继承访问权限是public，而class是private\n\n- struct的默认的数据访问控制是public，而class是private\n\n### 关键字inline\n\n　inline关键字修饰的函数称为“内联函数”，内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样\n\n　函数调用语句和直接把函数中的代码重新抄写一遍相比，带来了程序运行时间上的额外开销，一般情况下，这个开销可以忽略不计，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了，假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢\n\n### 作用域运算符::\n\n　作用域运算符::是运算符中等级最高的，可以分成三种：\n\n- 全局作用域符\n\n　当全局变量在某个局部作用中与其中某个局部变量重名，那么就可以用全局作用域符::来区分\n\t\n\t```\n\tint x = 1;   // 全局变量\n\t\n\tvoid func()\n\t{ \n\t　int x = 1;   // 局部变量\n\t　x = x + x;   // 局部变量，代码块中局部变量会覆盖全局变量\n\t　::x = ::x + x;   // 前两个x为全局变量，最后的x为局部变量\n\t}\n\t```\n\n- 类作用域符\n\n　为了避免不同的类有名称相同的成员，可以用类作用域符进行区分，类作用域符前面是类的名称，后面是该类的成员名称\n\n\t```\n\tclass A\n\t{\n\tpublic:\n\t　void func();\n\t}\n\t\n\tclass B\n\t{\n\tpublic:\n\t　void func();\n\t}\n\t\n\tvoid A::func()\n\t{\n\t　// ...\n\t}\n\t\n\tvoid B::func()\n\t{\n\t　// ...\n\t}\n\t```\n\n- 命名空间作用域符\n\n　命名空间作用域符可以区分不同命名空间中的成员，命名空间作用域符前面是命名空间的名称，后面是该命名空间的成员名称\n\n\t```\n\t#include <iostream>\n\tusing namespace std;\n\t\n\tnamespace A\n\t{\n\t　int x = 1;\n\t　\n\t　void fun()\n\t　{\n\t　　cout << \"A\" << endl;\n\t　}\n\t}\n\t\n\tnamespace B\n\t{\n\t　int x = 2;\n\t　\n\t　void fun()\n\t　{\n\t　　cout << \"B\" << endl;\n\t　}\n\t　\n\t　void fun2()\n\t　{\n\t　　cout << \"BB\" << endl;\n\t　}\n\t}\n\t\n\tint main()\n\t{\n\t　cout << A::x << endl;\n\t　cout << B::x << endl;\n\t\n\t　using namespace B;\n\t\n\t　A::fun();\n\t　fun();\n\t　fun2();\n\t　\n\t　return 0;\n\t}\n\t```\n\n","tags":["C++"]},{"title":"C++的内存分配和链接性","url":"/2019/04/11/C++的内存分配和链接性/","content":"\n　C++程序（包括其他语言的程序）由代码和数据两部分组成，代码存储在代码区中，数据根据类型的不同存储在不同的内存区域中，下面介绍内存区域的划分\n\n### C++的内存分配\n\n- **栈(stack)：**\n\n\t由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区，栈通常存储局部变量、函数参数等，在一个进程中，位于用户虚拟地址空间顶部的是栈，栈的地址向下生长\n\n- **堆(heap)：**\n\n\t由new分配的内存块存储区，堆中内存块的释放编译器不会检查，需要在代码中自己控制，一般一个new就需要对应一个delete，如果没有delete，会造成内存泄漏，在应用程序结束后，会自动回收\n\n- **自由存储区：**\n\n\t由malloc分配的内存块存储区，由free来回收，和堆的作用很类似\n\n- **全局/静态存储区：**\n\n\t全局变量和静态变量的存储区，在C语言中，全局变量和静态变量分为初始化的和未初始化的，未初始化的全局变量和静态变量会被用0来填充，存储在全局/静态存储区中的BSS(Block Started by Symbol)数据段，已经初始化的变量放在相邻的另一个数据段，在C++中已经没有这个区分，初始化的和未初始化的变量都共享同一块内存区\n\n- **常量存储区：**\n\n\t专门用来存放常量的存储区\n\n下面的代码显示了不同类型变量的存储方式：\n\n```\n#include <iostream>\nusing namespace std;\n\nconst int aa = 1;   // 常量存储区\n\nint bb = 2;   // 全局/静态存储区\nstatic int cc = 3;   // 全局/静态存储区\n\nint dd;   // 全局/静态存储区\nstatic int ee;   // 全局/静态存储区\n\nint main()\n{\n　int a;   // 栈(stack)\n　int b;   // 栈(stack)\n\n　static int c = 0;   // 全局/静态存储区\n　static int d;   // 全局/静态存储区\n\n　int *p = new int[5];   // 堆(heap)\n　delete []p;   // 一定要释放，否则会造成内存泄漏\n    \n　return 0;\n}\n```\n\n### 堆和栈的区别\n\n- **管理方式：**\n\n\t栈由编译器自动管理，无需手动控制；\n\t堆由new/delete来控制，申请后没有释放内存容易造成memory leak；\n\n- **空间大小：**\n\n\t一般在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的；\n\t对于栈来讲，一般都是有一定的空间大小的，例如在VC6下面，默认的栈空间大小是1M，也可以在工程中修改栈的大小；\n\n- **碎片问题：**\n\n\t频繁的new/delete势必会造成堆内存空间的不连续，从而造成大量的碎片；\n\t而栈则不存在这个问题；\n\n- **生长方向：**\n\n\t栈的生长方向是向下的，是向着内存地址减小的方向增长；\n\t堆的生长方向是向上的，也就是向着内存地址增加的方向；\n\n- **分配方式：**\n\n\t堆都是动态分配的，没有静态分配的堆；\n\t栈有静态分配和动态分配2种分配方式，都由编译器实现；\n\n- **分配效率：**\n\n\t计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，栈的分配效率比较高；\n\t而堆的分配效率比较低；\n\n### C++的链接性\n\n　C++栈中存储的自动变量一定是无链接性的，而全局/静态存储区存储的静态变量按照链接性可以分为三种，分别是：外部链接性，内部链接性和无链接性\n\n- **外部链接性：**\n\n\t外部链接性的静态变量在代码块之外声明，不带static，具有多文件作用域；\n\n- **内部链接性：**\n\n\t内部链接性的静态变量同样在代码块之外声明，用关键字static或者const修饰，作用域仅限于单文件；\n\n- **无链接性：**\n\n\t无链接性的静态变量在代码块中声明，用关键字static修饰，作用域仅限于声明的代码块中\n\n下面的代码显示了不同变量的链接性：\n\n```\n#include <iostream>\nusing namespace std;\n\nint x = 1;   // 声明外部链接性的变量\nstatic int y;    // 声明内部链接性的变量\n\nint func()\n{\n　static int z;   // 声明无链接的变量\n}\n\nint main()\n{\n　return 0;\n}\n```\n\n","tags":["C++"]},{"title":"理解Windows句柄","url":"/2019/04/10/理解Windows句柄/","content":"\n　开始Windows编程半年多，几乎每天都需要和各种Windows句柄打交道，一直把Windows句柄当做一个指针来使用，虽然在句柄的使用上没遇到问题，认识却停留在一知半解的层面，趁这段离职的时间，终于可以深入把Windows句柄理解清楚\n\n### 什么是Windows句柄\n\n　首先来看下微软自己对于句柄的定义：\n\n```\n《Microsoft Windows 3 Developer's Workshop》 (by Richard Wilton) [Microsoft Press]\n在Windows环境中，句柄是Windows系统用来标识被应用程序所建立或使用的对象的唯一整数\n这些对象包括：\n模块(module)、任务(task)、实例 (instance)、对话框(dialog)、文件(file)、\n内存块(block of memory)、菜单(menu)、控制(control)、字体(font)、\n资源(resource)[包括图标(icon)，光标 (cursor)，字符串(string)等]、\nGDI对象(GDI object)[包括位图(bitmap)，画刷(brush)，元文件（metafile），\n调色板(palette)，画笔(pen)，区域 (region)，以及设备描述表(device context)]\n```\n\n　数值上，句柄是一个32位的整数（32位系统下），逻辑上，句柄相当于指针的指针，实际上，句柄是Windows系统在内存中维护的一个对象（窗口等）内存物理地址列表的整数索引，是Windows中各个对象的一个唯一的、固定不变的ID（所谓“唯一”、“不变”是指在程序的一次运行过程中），通过句柄就可以找到对象在内存中的位置，从而去对内存中的对象进行操作\n　\n　注意句柄是对象生成时Windows系统指定分配的，属性是只读的，程序员不能修改句柄，程序员只能通过句柄调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事\n\n### 为什么需要Windows句柄\n\n　或许很多人会问，既然句柄的作用相当于指针，干脆直接获取对象在内存中的首地址，不就可以随时用这个地址访问对象了，为什么还需要通过句柄找到指针多此一举？\n\n　其实这样在Windows系统中行不通！\n\n　Windows系统是一个以虚拟内存为基础的操作系统，很多时候进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被替换出内存，当再次需要时，再装入内存，两次装入的地址基本上是不一样的，也就是说，同一对象在内存中的地址会变化，那么程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄\n\n　Windows系统为每个进程在内存中分配一定的空间，用来存放各个句柄，即各个32位无符号整型值（32位系统下），每个32位无符号整型值相当于一个指针，指向内存中的一个区域，而区域中存放的正是对象在内存中的地址，当对象在内存中的位置发生变化时，区域中存放的值被更新，变为当前时间点对象在内存中的地址，而在这个过程中，区域的位置以及对应句柄的值是不发生变化的，这个过程机制用下面的2张图来形象展示\n\n- 图1：程序运行到某时间点的内存快照\n\n![](/img/Windows/HANDLE_01.png)\n\n- 图2：程序往后运行到另一时刻时的内存快照，对象在内存中的位置已经发生变化，而区域的位置以及对应句柄的值没有发生变化\n\n![](/img/Windows/HANDLE_02.png)\n\n　通过这2张图就明白了句柄的作用：有一个固定的标识（句柄），指向一个固定的位置（区域），而区域中存放的值可以动态地变化（虚拟内存），他时刻记录着当前时间点对象在内存中的地址，这样无论对象的位置在内存中如何变化，只要掌握了句柄的值，就可以找到区域，进而找到该对象进行操作\n\n### 从源代码分析Windows句柄\n\n　在WinNT.h中，定义了大部分Windows系统里一些内部结构，包括通用句柄的结构\n\n```\ntypedef void *PVOID;\n \n#ifdef STRICT\ntypedef void *HANDLE;\n#define DECLARE_HANDLE(name) struct name##__ { int unused;};\ntypedef struct name##__ *name\n#else\ntypedef PVOID HANDLE;\n#define DECLARE_HANDLE(name) typedef HANDLE name\n#endif\n```\n\n　在Windef.h中做了特殊句柄的定义\n\n```\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HFONT);\n#endif\nDECLARE_HANDLE(HICON);\n#if !defined(_MAC) || !defined(WIN_INTERNAL)\nDECLARE_HANDLE(HMENU);\n#endif\nDECLARE_HANDLE(HMETAFILE);\nDECLARE_HANDLE(HINSTANCE);\ntypedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HPALETTE);\nDECLARE_HANDLE(HPEN);\n#endif\nDECLARE_HANDLE(HRGN);\nDECLARE_HANDLE(HRSRC);\nDECLARE_HANDLE(HSTR);\nDECLARE_HANDLE(HTASK);\nDECLARE_HANDLE(HWINSTA);\nDECLARE_HANDLE(HKL);\n```\n\n　微软把通用句柄HANDLE定义为void指针，显然是不想让人知道句柄的真实类型，但是通过分析代码可以发现，句柄就是一种指向结构体的指针，由于指向结构体指针可以强制截断只获取第一个字段，这里的struct结构体绝对不止一个字段，但是可以很容易猜到结构体的第一个字段就是逻辑地址（指针）\n\n### 窗口句柄和窗口指针\n\n　窗口对象是一个继承于CWnd类的C++类的对象，是Windows编程中最常用的对象，窗口句柄和窗口指针可以通过对方来相互获取\n\n- 从窗口指针获取窗口句柄\n\n```\nHWND hWnd;\nhWnd = GetDlgItem(IDC_STATIC_WND)->GetSafeHwnd();\n```\n\n- 从窗口句柄获取窗口指针\n\n```\n// HBITMAP m_hBitmap\nCBitmap *pBitmap = FromHandle(m_hBitmap);\n```\n\n\n","tags":["Windows编程"]},{"title":"从函数指针到回调函数","url":"/2019/04/09/从函数指针到回调函数/","content":"\n\n　C++(包括C语言)中最灵活的技术就是指针，在操作一个对象或者数组时，我们常常用到指针，可以给编程带来很多灵活性，而指针不仅仅能指向对象或者固定数据类型，还可以指向函数，这就是函数指针\n\n　有了函数指针，我们可以通过指针调用函数，更重要的是我们可以将函数指针作为参数传递给函数，进而可以实现回调函数(callback)功能，所以有了函数指针，我们的程序可以设计的更加灵活，这也正是C++的魅力(当然指针是一把双刃剑，使用不当也会引发灾难:)\n\n## 函数指针\n\n### 函数指针的简单定义\n\n　C++中函数声明由3部分组成，分别是函数的参数、返回类型和函数名，其中参数和返回类型这两项决定了函数类型，函数类型与函数名无关，以下例子中函数类型为int(int)\n\n```\n// 函数声明\nint PrintInt(int i);\n\n// 函数定义\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n```\n\n　声明一个指向某种函数类型的函数指针非常简单，只需要用指针替换函数名即可，以下例子中声明了一个函数指针，可以指向函数类型为int(int)的函数，这里要注意，函数指针 `(*pFunc)` 两边的括号必不可少，否则声明的就不再是函数指针，而是返回值为(int *)型指针的函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 注意: pFunc不是函数指针，而是返回值为(int *)的函数\nint *pFunc(int i);\n```\n\n　声明函数指针完成后，函数指针处于未初始化的状态，需要将函数地址赋值给函数指针，然后就可以通过函数指针来调用函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 将函数地址赋值给函数指针\n　pFunc = PrintInt;   // pFunc = &PrintInt; 也可以\n　\n　// 通过函数指针来调用函数\n　pFunc(1);   // (*pFunc)(1); 也可以\n　\n　return 0;\n}\n```\n\n　其实在声明和定义函数的时候，函数名就是一个函数指针，只不过是一个常量函数指针，而在声明函数指针的时候，声明的是一个变量函数指针\n\n### 函数指针的typedef定义\n\n　声明函数指针的格式为 `返回值 (*函数指针名)(参数列表)`，每次需要声明一个函数指针的时候，都需要这样声明一长串显然很麻烦，可以用typedef关键字，定义某一种类型的函数指针，给它一个别名，然后用别名去声明函数指针就会像声明一个int型变量一样方便\n\n```\n// 使用typedef时，PTRFUNC不再是具体指针\n// PTRFUNC表示指向某种函数类型的函数指针类型 (拗口)\ntypedef int (*PTRFUNC)(int i);\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 通过PTRFUNC声明指针，并赋值\n　PTRFUNC pFunc = PrintInt;\n　\n　// 通过函数指针来调用函数\n　pFunc(1);\n　\n　return 0;\n}\n```\n\n### 函数指针作为函数的参数\n\n　有了函数指针，我们就可以像传递普通指针那样将一个函数作为参数传递给另一个函数，这大大的增加了我们编程的灵活性\n\n```\n// 定义int(int,int)类型的函数指针\ntypedef int (*CALLFUNC)(int,int);\n\n// CALLFUNC类型的函数作为参数\nvoid HandleFunc(CALLFUNC pFunc,int x,int y)\n{\n　cout << pFunc(x, y) << endl;\n}\n\n// 加法函数\nint AddFunc(int x,int y)\n{\n　return (x + y);\n}\n\n// 减法函数\nint SubFunc(int x,int y)\n{\n　return (x - y);\n}\n\nint main()\n{\n　// 将函数指针作为参数传递给函数\n　// &符号可以省略\n　HandleFunc(&AddFunc, 2, 1);\n　HandleFunc(&SubFunc, 2, 1);\n　\n　return 0;\n}\n```\n\n## 回调函数\n\n　掌握了函数指针，以及将函数指针作为参数进行传递的方法，我们就能实现函数指针最有用的功能 —— 回调函数(callback)\n\n　对于很多C++初学者来说，往往会觉得回调函数很神秘，其实要完全搞清楚回调函数只需要明白两个问题：\n\n> - 什么是回调函数？\n> \n> - 为什么要使用回调函数？\n\n### 什么是回调函数？\n\n　网上对于回调函数的定义五花八门，简而言之，回调函数就是一个通过函数指针调用的函数，如果你把函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数\n\n### 为什么要使用回调函数？\n\n　同样用一句话概括使用回调函数的最大作用，就是实现通知机制 (除此之外，回调函数还可以调用者和被调用者解耦)\n\n　关于调用普通函数和回调函数，我们用订蛋糕做个比喻，调用普通函数就好像你直接去蛋糕店订一个蛋糕，订完之后，你并不知道蛋糕什么时候会做好，所以你就需要一直在蛋糕店等着，一直到蛋糕做好了，才能取蛋糕；而回调函数就好像你去蛋糕店订一个蛋糕，这时蛋糕店会留下你的联系方式，当蛋糕做好了，蛋糕店就会给你打电话，让你去取蛋糕\n\n```\n### 调用普通函数 ###\n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　bool MakeCake();   // 做蛋糕函数，如果做好了返回true，否则返回false　\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n};\n\nBaker::Baker():m_iTime(0){}\n\nbool Baker::MakeCake()\n{\n　// 每次调用该函数，m_iTime+1\n　m_iTime += 1;\n　\n　if (m_iTime == m_iMaxTime)\n　{\n　　cout << \"蛋糕做好了!\" << endl;\n　　return true;\n　}\n　\n　return false;\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\t\n　// 做蛋糕\n　while(1)\n　{\n　　// 客户如果想第一时间知道蛋糕做没做好，就必须每时每刻查看蛋糕的情况\n　　if( baker.MakeCake() )\n　　{\n　　　GetMyCake();\n　　　break;\n　　}\n　　else\n　　{\n　　　cout << \"蛋糕没做好\" << endl;\n　　}\n　}\n\n　return 0;\n}\n```\n\n　我们如果想要第一时间知道蛋糕有没有做好，就必须一直查询蛋糕有没有做好，换句话说，我们不能去干别的事情，如果这是一个线程的话，那么这个线程在这段时间就不能做其他事情，至少不能100%专注做别的事情，因为必须保持关注蛋糕有没有做好，这显然很低效，而使用回调函数，就可以实现通知机制，大大提升效率\n\n```\n### 回调函数 ###\n\n// 声明回调函数\ntypedef void (*CALLBACKFUNC)(void);  \n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　void MakeCake();   // 做蛋糕函数\n　void Invoke(CALLBACKFUNC);   // 注册回调函数：留下订蛋糕的人的联系方式\n　void Notify();   // 通知订蛋糕的人\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n　CALLBACKFUNC m_pfCallBack;   // 回调函数\n};\n\nBaker::Baker():m_iTime(0){}\n\nvoid Baker::MakeCake()\n{\n　while(m_iTime < m_iMaxTime)\n　{\n　　// 每次调用该函数，m_iTime+1\n　　m_iTime += 1;\n　}\n　\n　cout << \"蛋糕做好了!\" << endl;\n　\n　Notify();\n}\n\nvoid Baker::Invoke(CALLBACKFUNC pFunc)\n{\n　m_pfCallBack = pFunc;\n　cout << \"留下了你的联系方式!\" << endl;\n}\n\nvoid Baker::Notify()\n{\n　if(m_pfCallBack)\n　　m_pfCallBack();\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\n　// 注册：留下联系方式\n　baker.Invoke(GetMyCake);\n　\n　// 注册之后，客户就不需要实时查询了\n　cout << \"好了请通知我!\" << endl;\n　\n　// 做蛋糕\n　baker.MakeCake();\n　\n　return 0;\n}\n```\n\n　在类中使用回调函数，先要注册回调函数，然后在某项任务完成以后，调用回调函数实现通知机制，比如我们做异步加载时，如果我们需要某个资源，就可以去加载线程注册一下，然后主线程继续做其他工作，加载线程加载完需要的资源之后，通过回调函数通知主线程，这样加载和主要功能就可以同时进行，大大的提升了用户体验\n\n\n","tags":["C++"]},{"title":"Hexo+GitHub搭建属于自己的Blog","url":"/2019/04/08/Hexo+GitHub搭建属于自己的Blog/","content":"\n　现在市面上可供程序猿们选择的博客已经有很多，如常见的CSDN，博客园和简书等等，然而这些平台有着各种各样的限制，各种不自由，加上烦人的小广告，让你的Blog看起来一点也不geek，一点都没“范儿”\n\n　有一些程序猿，包括我自己也尝试过搭建LNMP环境，用WordPress建站，但是这种方案的成本实在太高了，不光是服务器的购买成本，单单是去维护网站运行就需要花费不少精力，特别是对于LNMP架构不熟悉的人来说，Debug也常常很让人头疼\n\n　于是Hexo+GitHub成为了我选择的一种折中方案（也可以选择jekyll+GitHub的方案，实现类似），用Hexo作为一个快速简洁的博客框架，在GitHub Page平台上托管博客，可以非常方便省心的搭建起属于我们自己的博客\n\n## Hexo搭建\n　Hexo是一个基于Node.js的静态博客框架，安装依赖少，可以方便的生成静态网页，下面介绍macOS环境搭建Hexo的步骤:\n\n### 安装Node.js\n　Node是一个让JavaScript运行在服务端的开发平台，JavaScript是一门流行的前端语言，但是在2009年，国外开发者Ryan推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js，第一次把JavaScript带入到后端服务器开发，让Node一下子就火了起来\n\n　直接从Node.js官网下载安装包即可一键安装，安装包括两部分，一部分是安装Node.js，另一部分是安装npm，npm全称Node Package Manager，就是Node包的一个管理工具，是Node.js下主流的套件管理器，类似于Ubuntu的apt，python的pip等\n\n![](/img/hexo/01.png)\n(Node.js安装截图)\n\n　安装完后，用命令行检查有没有安装成功\n\n``` bash\nnode -v\nnpm -v\n```\n\n### 安装Hexo\n　Hexo是一款基于Node.js的静态博客框架，用命令可以快速安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n\n　如果执行上面命令遇到报错Error: EACCES: permission denied，加上sudo重新运行就行了\n\n``` bash\nsudo npm install -g hexo-cli\n```\n\n### 初始化Hexo\n　依次执行以下命令就可以完成Hexo的初始化，非常简单，其中blog表示博客项目存放的根目录，可以替换自己喜欢的名字\n\n``` bash\nhexo init blog\ncd blog\nnpm install\n```\n\n　node项目目录下带有package.json，\"dependencies\"字段标识了项目所使用的依赖模块，`npm install`命令会检查并自动下载依赖模块\n\n![](/img/hexo/02.png)\n\n　Hexo初始化完成后，指定文件夹目录下有：\n- node_modules: 依赖包\n- public：存放生成的页面\n- scaffolds：生成文章的一些模板\n- source：用来存放你的文章\n- themes：主题\n- _config.yml: 博客的配置文件\n\n### 运行Hexo\n\n``` bash\nhexo server\n```\n\n　运行完命令后，浏览器打开`http://localhost:4000`，看到《Hello World》，Hexo就已经在本地成功跑起来了，大功告成~\n\n![](/img/hexo/03.png)\n\n### 部署Hexo\n\n　每次写了新的博客或者更改了主题样式，都需要重新部署hexo，按照下面三个步骤依次进行：\n\n``` bash\nhexo clean\nhexo generate\nhexo deploy\n```\n\n　hexo clean清除了你之前生成的东西\n\n　运行`hexo generate`命令，Hexo引擎将markdown格式的文件解析成可以使用浏览器查看的HTML文件，HTML文件存储在blog/public目录下\n\n### 配置Hexo主题\n\n　Hexo博客主题都存放在blog/themes文件夹下，Hexo提供了默认主题landscape，如果想要替换自己的主题，可以把主题放在blog/themes文件夹下，然后修改config.yml文件的theme字段\n\n![](/img/hexo/04.png)\n\n## GitHub Page托管博客\n~\n\n(Updating...)\n\n","tags":["程序猿的自我修养"]}]