[{"title":"C++的内存分配和链接性","url":"/2019/04/11/C++的内存分配和链接性/","content":"\n　C++程序（包括其他语言的程序）由代码和数据两部分组成，代码存储在代码区中，数据根据类型的不同存储在不同的内存区域中，下面介绍内存区域的划分\n\n### C++的内存分配\n\n- **栈(stack)：**\n\n\t由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区，栈通常存储局部变量、函数参数等，在一个进程中，位于用户虚拟地址空间顶部的是栈，栈的地址向下生长\n\n- **堆(heap)：**\n\n\t由new分配的内存块存储区，堆中内存块的释放编译器不会检查，需要在代码中自己控制，一般一个new就需要对应一个delete，如果没有delete，会造成内存泄漏，在应用程序结束后，会自动回收\n\n- **自由存储区：**\n\n\t由malloc分配的内存块存储区，由free来回收，和堆的作用很类似\n\n- **全局/静态存储区：**\n\n\t全局变量和静态变量的存储区，在C语言中，全局变量和静态变量分为初始化的和未初始化的，未初始化的全局变量和静态变量会被用0来填充，存储在全局/静态存储区中的BSS(Block Started by Symbol)数据段，已经初始化的变量放在相邻的另一个数据段，在C++中已经没有这个区分，初始化的和未初始化的变量都共享同一块内存区\n\n- **常量存储区：**\n\n\t专门用来存放常量的存储区\n\n下面的代码显示了不同类型变量的存储方式：\n\n```\n#include <iostream>\nusing namespace std;\n\nconst int aa = 1;   // 常量存储区\n\nint bb = 2;   // 全局/静态存储区\nstatic int cc = 3;   // 全局/静态存储区\n\nint dd;   // 全局/静态存储区\nstatic int ee;   // 全局/静态存储区\n\nint main()\n{\n　int a;   // 栈(stack)\n　int b;   // 栈(stack)\n\n　static int c = 0;   // 全局/静态存储区\n　static int d;   // 全局/静态存储区\n\n　int *p = new int[5];   // 堆(heap)\n　delete []p;   // 一定要释放，否则会造成内存泄漏\n    \n　return 0;\n}\n```\n\n### 堆和栈的区别\n\n- **管理方式：**\n\n\t栈由编译器自动管理，无需手动控制；\n\t堆由new/delete来控制，申请后没有释放内存容易造成memory leak；\n\n- **空间大小：**\n\n\t一般在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的；\n\t对于栈来讲，一般都是有一定的空间大小的，例如在VC6下面，默认的栈空间大小是1M，也可以在工程中修改栈的大小；\n\n- **碎片问题：**\n\n\t频繁的new/delete势必会造成堆内存空间的不连续，从而造成大量的碎片；\n\t而栈则不存在这个问题；\n\n- **生长方向：**\n\n\t栈的生长方向是向下的，是向着内存地址减小的方向增长；\n\t堆的生长方向是向上的，也就是向着内存地址增加的方向；\n\n- **分配方式：**\n\n\t堆都是动态分配的，没有静态分配的堆；\n\t栈有静态分配和动态分配2种分配方式，都由编译器实现；\n\n- **分配效率：**\n\n\t计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，栈的分配效率比较高；\n\t而堆的分配效率比较低；\n\n### C++的链接性\n\n　C++栈中存储的自动变量一定是无链接性的，而全局/静态存储区存储的静态变量按照链接性可以分为三种，分别是：外部链接性，内部链接性和无链接性\n\n- **外部链接性：**\n\n\t外部链接性的静态变量在代码块之外声明，不带static，具有多文件作用域；\n\n- **内部链接性：**\n\n\t内部链接性的静态变量同样在代码块之外声明，用关键字static或者const修饰，作用域仅限于单文件；\n\n- **无链接性：**\n\n\t无链接性的静态变量在代码块中声明，用关键字static修饰，作用域仅限于声明的代码块中\n\n下面的代码显示了不同变量的链接性：\n\n```\n#include <iostream>\nusing namespace std;\n\nint x = 1;   // 声明外部链接性的变量\nstatic int y;    // 声明内部链接性的变量\n\nint func()\n{\n　static int z;   // 声明无链接的变量\n}\n\nint main()\n{\n　return 0;\n}\n```\n\n","tags":["C++"]},{"title":"理解Windows句柄","url":"/2019/04/10/理解Windows句柄/","content":"\n　开始Windows编程半年多，几乎每天都需要和各种Windows句柄打交道，一直把Windows句柄当做一个指针来使用，虽然在句柄的使用上没遇到问题，认识却停留在一知半解的层面，趁这段离职的时间，终于可以深入把Windows句柄理解清楚\n\n### 什么是Windows句柄\n\n　首先来看下微软自己对于句柄的定义：\n\n```\n《Microsoft Windows 3 Developer's Workshop》 (by Richard Wilton) [Microsoft Press]\n在Windows环境中，句柄是Windows系统用来标识被应用程序所建立或使用的对象的唯一整数\n这些对象包括：\n模块(module)、任务(task)、实例 (instance)、对话框(dialog)、文件(file)、\n内存块(block of memory)、菜单(menu)、控制(control)、字体(font)、\n资源(resource)[包括图标(icon)，光标 (cursor)，字符串(string)等]、\nGDI对象(GDI object)[包括位图(bitmap)，画刷(brush)，元文件（metafile），\n调色板(palette)，画笔(pen)，区域 (region)，以及设备描述表(device context)]\n```\n\n　数值上，句柄是一个32位的整数（32位系统下），逻辑上，句柄相当于指针的指针，实际上，句柄是Windows系统在内存中维护的一个对象（窗口等）内存物理地址列表的整数索引，是Windows中各个对象的一个唯一的、固定不变的ID（所谓“唯一”、“不变”是指在程序的一次运行过程中），通过句柄就可以找到对象在内存中的位置，从而去对内存中的对象进行操作\n　\n　注意句柄是对象生成时Windows系统指定分配的，属性是只读的，程序员不能修改句柄，程序员只能通过句柄调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事\n\n### 为什么需要Windows句柄\n\n　或许很多人会问，既然句柄的作用相当于指针，干脆直接获取对象在内存中的首地址，不就可以随时用这个地址访问对象了，为什么还需要通过句柄找到指针多此一举？\n\n　其实这样在Windows系统中行不通！\n\n　Windows系统是一个以虚拟内存为基础的操作系统，很多时候进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被替换出内存，当再次需要时，再装入内存，两次装入的地址基本上是不一样的，也就是说，同一对象在内存中的地址会变化，那么程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄\n\n　Windows系统为每个进程在内存中分配一定的空间，用来存放各个句柄，即各个32位无符号整型值（32位系统下），每个32位无符号整型值相当于一个指针，指向内存中的一个区域，而区域中存放的正是对象在内存中的地址，当对象在内存中的位置发生变化时，区域中存放的值被更新，变为当前时间点对象在内存中的地址，而在这个过程中，区域的位置以及对应句柄的值是不发生变化的，这个过程机制用下面的2张图来形象展示\n\n- 图1：程序运行到某时间点的内存快照\n\n![](/img/Windows/HANDLE_01.png)\n\n- 图2：程序往后运行到另一时刻时的内存快照，对象在内存中的位置已经发生变化，而区域的位置以及对应句柄的值没有发生变化\n\n![](/img/Windows/HANDLE_02.png)\n\n　通过这2张图就明白了句柄的作用：有一个固定的标识（句柄），指向一个固定的位置（区域），而区域中存放的值可以动态地变化（虚拟内存），他时刻记录着当前时间点对象在内存中的地址，这样无论对象的位置在内存中如何变化，只要掌握了句柄的值，就可以找到区域，进而找到该对象进行操作\n\n### 从源代码分析Windows句柄\n\n　在WinNT.h中，定义了大部分Windows系统里一些内部结构，包括通用句柄的结构\n\n```\ntypedef void *PVOID;\n \n#ifdef STRICT\ntypedef void *HANDLE;\n#define DECLARE_HANDLE(name) struct name##__ { int unused;};\ntypedef struct name##__ *name\n#else\ntypedef PVOID HANDLE;\n#define DECLARE_HANDLE(name) typedef HANDLE name\n#endif\n```\n\n　在Windef.h中做了特殊句柄的定义\n\n```\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HFONT);\n#endif\nDECLARE_HANDLE(HICON);\n#if !defined(_MAC) || !defined(WIN_INTERNAL)\nDECLARE_HANDLE(HMENU);\n#endif\nDECLARE_HANDLE(HMETAFILE);\nDECLARE_HANDLE(HINSTANCE);\ntypedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HPALETTE);\nDECLARE_HANDLE(HPEN);\n#endif\nDECLARE_HANDLE(HRGN);\nDECLARE_HANDLE(HRSRC);\nDECLARE_HANDLE(HSTR);\nDECLARE_HANDLE(HTASK);\nDECLARE_HANDLE(HWINSTA);\nDECLARE_HANDLE(HKL);\n```\n\n　微软把通用句柄HANDLE定义为void指针，显然是不想让人知道句柄的真实类型，但是通过分析代码可以发现，句柄就是一种指向结构体的指针，由于指向结构体指针可以强制截断只获取第一个字段，这里的struct结构体绝对不止一个字段，但是可以很容易猜到结构体的第一个字段就是逻辑地址（指针）\n\n### 窗口句柄和窗口指针\n\n　窗口对象是一个继承于CWnd类的C++类的对象，是Windows编程中最常用的对象，窗口句柄和窗口指针可以通过对方来相互获取\n\n- 从窗口指针获取窗口句柄\n\n```\nHWND hWnd;\nhWnd = GetDlgItem(IDC_STATIC_WND)->GetSafeHwnd();\n```\n\n- 从窗口句柄获取窗口指针\n\n```\n// HBITMAP m_hBitmap\nCBitmap *pBitmap = FromHandle(m_hBitmap);\n```\n\n\n","tags":["Windows编程"]},{"title":"从函数指针到回调函数","url":"/2019/04/09/从函数指针到回调函数/","content":"\n\n　C++(包括C语言)中最灵活的技术就是指针，在操作一个对象或者数组时，我们常常用到指针，可以给编程带来很多灵活性，而指针不仅仅能指向对象或者固定数据类型，还可以指向函数，这就是函数指针\n\n　有了函数指针，我们可以通过指针调用函数，更重要的是我们可以将函数指针作为参数传递给函数，进而可以实现回调函数(callback)功能，所以有了函数指针，我们的程序可以设计的更加灵活，这也正是C++的魅力(当然指针是一把双刃剑，使用不当也会引发灾难:)\n\n## 函数指针\n\n### 函数指针的简单定义\n\n　C++中函数声明由3部分组成，分别是函数的参数、返回类型和函数名，其中参数和返回类型这两项决定了函数类型，函数类型与函数名无关，以下例子中函数类型为int(int)\n\n```\n// 函数声明\nint PrintInt(int i);\n\n// 函数定义\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n```\n\n　声明一个指向某种函数类型的函数指针非常简单，只需要用指针替换函数名即可，以下例子中声明了一个函数指针，可以指向函数类型为int(int)的函数，这里要注意，函数指针 `(*pFunc)` 两边的括号必不可少，否则声明的就不再是函数指针，而是返回值为(int *)型指针的函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 注意: pFunc不是函数指针，而是返回值为(int *)的函数\nint *pFunc(int i);\n```\n\n　声明函数指针完成后，函数指针处于未初始化的状态，需要将函数地址赋值给函数指针，然后就可以通过函数指针来调用函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 将函数地址赋值给函数指针\n　pFunc = PrintInt;   // pFunc = &PrintInt; 也可以\n　\n　// 通过函数指针来调用函数\n　pFunc(1);   // (*pFunc)(1); 也可以\n　\n　return 0;\n}\n```\n\n　其实在声明和定义函数的时候，函数名就是一个函数指针，只不过是一个常量函数指针，而在声明函数指针的时候，声明的是一个变量函数指针\n\n### 函数指针的typedef定义\n\n　声明函数指针的格式为 `返回值 (*函数指针名)(参数列表)`，每次需要声明一个函数指针的时候，都需要这样声明一长串显然很麻烦，可以用typedef关键字，定义某一种类型的函数指针，给它一个别名，然后用别名去声明函数指针就会像声明一个int型变量一样方便\n\n```\n// 使用typedef时，PTRFUNC不再是具体指针\n// PTRFUNC表示指向某种函数类型的函数指针类型 (拗口)\ntypedef int (*PTRFUNC)(int i);\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 通过PTRFUNC声明指针，并赋值\n　PTRFUNC pFunc = PrintInt;\n　\n　// 通过函数指针来调用函数\n　pFunc(1);\n　\n　return 0;\n}\n```\n\n### 函数指针作为函数的参数\n\n　有了函数指针，我们就可以像传递普通指针那样将一个函数作为参数传递给另一个函数，这大大的增加了我们编程的灵活性\n\n```\n// 定义int(int,int)类型的函数指针\ntypedef int (*CALLFUNC)(int,int);\n\n// CALLFUNC类型的函数作为参数\nvoid HandleFunc(CALLFUNC pFunc,int x,int y)\n{\n　cout << pFunc(x, y) << endl;\n}\n\n// 加法函数\nint AddFunc(int x,int y)\n{\n　return (x + y);\n}\n\n// 减法函数\nint SubFunc(int x,int y)\n{\n　return (x - y);\n}\n\nint main()\n{\n　// 将函数指针作为参数传递给函数\n　// &符号可以省略\n　HandleFunc(&AddFunc, 2, 1);\n　HandleFunc(&SubFunc, 2, 1);\n　\n　return 0;\n}\n```\n\n## 回调函数\n\n　掌握了函数指针，以及将函数指针作为参数进行传递的方法，我们就能实现函数指针最有用的功能 —— 回调函数(callback)\n\n　对于很多C++初学者来说，往往会觉得回调函数很神秘，其实要完全搞清楚回调函数只需要明白两个问题：\n\n> - 什么是回调函数？\n> \n> - 为什么要使用回调函数？\n\n### 什么是回调函数？\n\n　网上对于回调函数的定义五花八门，简而言之，回调函数就是一个通过函数指针调用的函数，如果你把函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数\n\n### 为什么要使用回调函数？\n\n　同样用一句话概括使用回调函数的最大作用，就是实现通知机制 (除此之外，回调函数还可以调用者和被调用者解耦)\n\n　关于调用普通函数和回调函数，我们用订蛋糕做个比喻，调用普通函数就好像你直接去蛋糕店订一个蛋糕，订完之后，你并不知道蛋糕什么时候会做好，所以你就需要一直在蛋糕店等着，一直到蛋糕做好了，才能取蛋糕；而回调函数就好像你去蛋糕店订一个蛋糕，这时蛋糕店会留下你的联系方式，当蛋糕做好了，蛋糕店就会给你打电话，让你去取蛋糕\n\n```\n### 调用普通函数 ###\n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　bool MakeCake();   // 做蛋糕函数，如果做好了返回true，否则返回false　\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n};\n\nBaker::Baker():m_iTime(0){}\n\nbool Baker::MakeCake()\n{\n　// 每次调用该函数，m_iTime+1\n　m_iTime += 1;\n　\n　if (m_iTime == m_iMaxTime)\n　{\n　　cout << \"蛋糕做好了!\" << endl;\n　　return true;\n　}\n　\n　return false;\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\t\n　// 做蛋糕\n　while(1)\n　{\n　　// 客户如果想第一时间知道蛋糕做没做好，就必须每时每刻查看蛋糕的情况\n　　if( baker.MakeCake() )\n　　{\n　　　GetMyCake();\n　　　break;\n　　}\n　　else\n　　{\n　　　cout << \"蛋糕没做好\" << endl;\n　　}\n　}\n\n　return 0;\n}\n```\n\n　我们如果想要第一时间知道蛋糕有没有做好，就必须一直查询蛋糕有没有做好，换句话说，我们不能去干别的事情，如果这是一个线程的话，那么这个线程在这段时间就不能做其他事情，至少不能100%专注做别的事情，因为必须保持关注蛋糕有没有做好，这显然很低效，而使用回调函数，就可以实现通知机制，大大提升效率\n\n```\n### 回调函数 ###\n\n// 声明回调函数\ntypedef void (*CALLBACKFUNC)(void);  \n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　void MakeCake();   // 做蛋糕函数\n　void Invoke(CALLBACKFUNC);   // 注册回调函数：留下订蛋糕的人的联系方式\n　void Notify();   // 通知订蛋糕的人\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n　CALLBACKFUNC m_pfCallBack;   // 回调函数\n};\n\nBaker::Baker():m_iTime(0){}\n\nvoid Baker::MakeCake()\n{\n　while(m_iTime < m_iMaxTime)\n　{\n　　// 每次调用该函数，m_iTime+1\n　　m_iTime += 1;\n　}\n　\n　cout << \"蛋糕做好了!\" << endl;\n　\n　Notify();\n}\n\nvoid Baker::Invoke(CALLBACKFUNC pFunc)\n{\n　m_pfCallBack = pFunc;\n　cout << \"留下了你的联系方式!\" << endl;\n}\n\nvoid Baker::Notify()\n{\n　if(m_pfCallBack)\n　　m_pfCallBack();\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\n　// 注册：留下联系方式\n　baker.Invoke(GetMyCake);\n　\n　// 注册之后，客户就不需要实时查询了\n　cout << \"好了请通知我!\" << endl;\n　\n　// 做蛋糕\n　baker.MakeCake();\n　\n　return 0;\n}\n```\n\n　在类中使用回调函数，先要注册回调函数，然后在某项任务完成以后，调用回调函数实现通知机制，比如我们做异步加载时，如果我们需要某个资源，就可以去加载线程注册一下，然后主线程继续做其他工作，加载线程加载完需要的资源之后，通过回调函数通知主线程，这样加载和主要功能就可以同时进行，大大的提升了用户体验\n\n\n","tags":["C++"]},{"title":"Hexo+GitHub搭建属于自己的Blog","url":"/2019/04/08/Hexo+GitHub搭建属于自己的Blog/","content":"\n　现在市面上可供程序猿们选择的博客已经有很多，如常见的CSDN，博客园和简书等等，然而这些平台有着各种各样的限制，各种不自由，加上烦人的小广告，让你的Blog看起来一点也不geek，一点都没“范儿”\n\n　有一些程序猿，包括我自己也尝试过搭建LNMP环境，用WordPress建站，但是这种方案的成本实在太高了，不光是服务器的购买成本，单单是去维护网站运行就需要花费不少精力，特别是对于LNMP架构不熟悉的人来说，Debug也常常很让人头疼\n\n　于是Hexo+GitHub成为了我选择的一种折中方案（也可以选择jekyll+GitHub的方案，实现类似），用Hexo作为一个快速简洁的博客框架，在GitHub Page平台上托管博客，可以非常方便省心的搭建起属于我们自己的博客\n\n## Hexo搭建\n　Hexo是一个基于Node.js的静态博客框架，安装依赖少，可以方便的生成静态网页，下面介绍macOS环境搭建Hexo的步骤:\n\n### 安装Node.js\n　Node是一个让JavaScript运行在服务端的开发平台，JavaScript是一门流行的前端语言，但是在2009年，国外开发者Ryan推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js，第一次把JavaScript带入到后端服务器开发，让Node一下子就火了起来\n\n　直接从Node.js官网下载安装包即可一键安装，安装包括两部分，一部分是安装Node.js，另一部分是安装npm，npm全称Node Package Manager，就是Node包的一个管理工具，是Node.js下主流的套件管理器，类似于Ubuntu的apt，python的pip等\n\n![](/img/hexo/01.png)\n(Node.js安装截图)\n\n　安装完后，用命令行检查有没有安装成功\n\n``` bash\nnode -v\nnpm -v\n```\n\n### 安装Hexo\n　Hexo是一款基于Node.js的静态博客框架，用命令可以快速安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n\n　如果执行上面命令遇到报错Error: EACCES: permission denied，加上sudo重新运行就行了\n\n``` bash\nsudo npm install -g hexo-cli\n```\n\n### 初始化Hexo\n　依次执行以下命令就可以完成Hexo的初始化，非常简单，其中blog表示博客项目存放的根目录，可以替换自己喜欢的名字\n\n``` bash\nhexo init blog\ncd blog\nnpm install\n```\n\n　node项目目录下带有package.json，\"dependencies\"字段标识了项目所使用的依赖模块，`npm install`命令会检查并自动下载依赖模块\n\n![](/img/hexo/02.png)\n\n　Hexo初始化完成后，指定文件夹目录下有：\n- node_modules: 依赖包\n- public：存放生成的页面\n- scaffolds：生成文章的一些模板\n- source：用来存放你的文章\n- themes：主题\n- _config.yml: 博客的配置文件\n\n### 运行Hexo\n\n``` bash\nhexo server\n```\n\n　运行完命令后，浏览器打开`http://localhost:4000`，看到《Hello World》，Hexo就已经在本地成功跑起来了，大功告成~\n\n![](/img/hexo/03.png)\n\n### 部署Hexo\n\n　每次写了新的博客或者更改了主题样式，都需要重新部署hexo，按照下面三个步骤依次进行：\n\n``` bash\nhexo clean\nhexo generate\nhexo deploy\n```\n\n　hexo clean清除了你之前生成的东西\n\n　运行`hexo generate`命令，Hexo引擎将markdown格式的文件解析成可以使用浏览器查看的HTML文件，HTML文件存储在blog/public目录下\n\n### 配置Hexo主题\n\n　Hexo博客主题都存放在blog/themes文件夹下，Hexo提供了默认主题landscape，如果想要替换自己的主题，可以把主题放在blog/themes文件夹下，然后修改config.yml文件的theme字段\n\n![](/img/hexo/04.png)\n\n## GitHub Page托管博客\n~\n\n(Updating...)\n\n","tags":["程序猿的自我修养"]}]