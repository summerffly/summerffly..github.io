[{"title":"观察者(Observer)模式","url":"/2019/04/15/观察者(Observer)模式/","content":"\n　软件架构中不同的模块(或者类)之间的关联关系分为 `紧耦合` 和 `松耦合` 两种，紧耦合系统中更新一个模块会导致其它关联耦合模块的变化，在一些要求模块间更加独立的系统中，松耦合显然更为合适，松耦合系统通常是基于消息的系统，观察者模式就是实现松耦合系统的常用方式\n\n　观察者模式可以说是应用最多、影响最广的模式之一，观察者模式建立一对多(Subject-Observer)的依赖关系，并且做到当“一”(Subject)变化的时候，这个“一”的“多”(Observer)也都将被通知\n\n　软件开发中经典的MVC(Model-View-Controller)框架是观察者模式最好的一个实例，使用MVC框架的目的是将Model和View的实现分离，如果View改变，则通过Controller去同步改变Model，而如果Model改变，则通过观察者模式去通知View更新\n\n### 观察者模式的定义\n\n　观察者模式定义对象间的一对多的关系，当一个对象的状态发生改变时，所有关注他的对象都会被通知并被自动更新，这种交互也称为发布-订阅(publish-subscribe)，这个“一”(Subject)称为发布者，这个“一”的“多”(Observer)称为观察者，发布者发出通知时，并不需要知道谁是他的观察者\n\n![](/img/DesignPattern/Observer.jpg)\n\n　UML类图中目标(Subject)对象提供了注册(Attach)和注销(Detach)两个操作接口，对目标感兴趣的对象可以通过这两个操作接口来订阅目标对象，从而成为目标的观察者(Observer)，这样当目标状态改变时，会通过通知(Notify)接口通知所有依赖于他的观察者，所有的观察者接收到通知后，会通过更新(Update)操作接口来做出相应的操作\n\n### 观察者模式的代码实现(C++)\n\n```\n// 模拟通知公司内部员工的场景\n\n#include <iostream>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n// 抽象观察者\nclass Observer;\n\n// 抽象发布者\nclass Subject\n{\npublic:\n　string action;\n　virtual void attach(Observer *) = 0;\n　virtual void detach(Observer *) = 0;\n　virtual void notify() = 0;\nprotected:\n　list<Observer *> observers;\n}\n\nclass Observer\n{\npublic:\n　// 构造函数\n　Observer(string name, Subject *subject)\n　{\n　　this->name = name;\n　　this->subject = subject;\n　}\n　virtual void update() = 0;\nprotected:\n　string name;\n　Subject *subject;\n}\n\n// 具体发布者 - 秘书\nclass Secretary : public Subject\n{\n　void attach(Observer *observer)\n　{\n　　observers.push_back(observer);\n　}\n\n　void detach(Observer *observer)\n　{\n　　list<Observer *>::iterator iter = observers.begin();\n　　while(iter != observers.end())\n　　{\n　　　if((*iter) == observer)\n　　　{\n　　　　observers.erase(iter);\n　　　}\n　　　++iter;\n　　}\n　}\n\n　void notify()\n　{\n　　list<Observer *>::iterator iter = observers.begin();\n　　while(iter != observers.end())\n　　{\n　　　(*iter)->update();\n　　　++iter;\n　　}\n　}\n}\n\n// 具体观察者 - 炒股同事\nclass StockObserver : public Observer\n{\npublic:\n　StockObserver(string name, Subject *subject) : Observer(name, subject){}\n　void update();\n}\n\nvoid StockObserver::update()\n{\n　cout << name << \" 收到消息：\" << subject->action << endl;\n　if(subject->action == \"经理来了！\")\n　{\n　　cout << \"马上关闭股票，装做很认真工作的样子！\" << endl;\n　}\n}\n\n// 具体观察者 - 看球同事\nclass FIFAObserver : public Observer\n{\npublic:\n　FIFAObserver(string name, Subject *subject) : Observer(name, subject){}\n　void update();\n}\n\nvoid FIFAObserver::update()\n{\n　cout << name << \" 收到消息：\" << subject->action << endl;\n　if(subject->action == \"经理来了！\")\n　{\n　　cout << \"马上关闭FIFA，装做很认真工作的样子！\" << endl;\n　}\n}\n\nint main()\n{\n　// 创建发布者\n　Subject *SS = new Secretary();\n　// 创建观察者\n　Observer *SO = new StockObserver(\"stock observer\", SS);\n　Observer *FO = new FIFAObserver(\"fifa observer\", SS);\n　\n　// 加入观察者队列\n　SS->attach(SO);\n　SS->attach(FO);\n　\n　// 通知事件A\n　SS->action = \"去吃饭了！\";\n　SS->notify();\n　cout << endl;\n　\n　// 通知事件B\n　SS->action = \"经理来了！\";\n　SS->notify();\n　cout << endl;\n\n　return 0;\n}\n\n```\n\n\n\n\n","tags":["设计模式"]},{"title":"迭代器(Iterator)模式","url":"/2019/04/15/迭代器(Iterator)模式/","content":"\n　当我们外出旅行，住在酒店看电视的时候，我们使用 `前一频道` 和 `后一频道` 按钮可以很方便的换电视台，当按下 `后一频道` 按钮时，将切换到下一个预置的电视台，我们并不知道也不需要去记几号频道对应的是哪个电视台，当切换频道时，我们只关心电视台播放的内容是不是自己喜欢的\n\n　看电视的场景反应的其实迭代器模式的目的，我们会需要一种方法去顺序的访问某个集合中的每个元素，只需要关心元素的具体内容，并不需要关心其他细节，C++ STL中访问各种容器的iterators，就是一个迭代器的实例\n\n### 迭代器模式的定义\n\n　迭代器模式提供一种方法访问一个容器对象中的各个元素，而不暴露该对象的内部细节，迭代器是为容器对象服务的，分离了聚合对象与其遍历行为，迭代器提供了遍历容器的方法，容器只需要管理增减元素，遍历的工作就交给迭代器完成\n\n![](/img/DesignPattern/Iterator.jpg)\n\n　UML类图中抽象迭代器(Iterator)除了提供next()接口，经常也会提供first()、currentItem()、isDone()等接口\n\n### 迭代器模式的代码实现(C++)\n\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate<class Item>\nclass Iterator\n{\npublic:\n　virtual void first()=0;\n　virtual void next()=0;\n　virtual Item* currentItem()=0;\n　virtual bool isDone()=0;\n　virtual ~Iterator(){}\n};\n\ntemplate<class Item>\nclass ConcreteAggregate;\n\ntemplate<class Item>\nclass ConcreteIterator : public Iterator<Item>\n{\npublic:\n　ConcreteIterator(ConcreteAggregate<Item> *a):aggr(a),cur(0){}\n　\n　virtual void first()\n　{\n　　cur=0;\n　}\n　\n　virtual void next()\n　{\n　　if(cur < aggr->getLen())\n　　cur++;\n　}\n　\n　virtual Item* currentItem()\n　{\n　　if(cur < aggr->getLen())\n　　　return &(*aggr)[cur];\n　　else\n　　　return NULL;\n　}\n\n　virtual bool isDone()\n　{\n　　return (cur >= aggr->getLen());\n　}\n\nprivate:\n　ConcreteAggregate<Item> *aggr;\n　int cur;\n};\n\ntemplate<class Item>\nclass Aggregate\n{\npublic:\n　virtual Iterator<Item>* createIterator()=0;\n　virtual ~Aggregate(){}\n};\n\ntemplate<class Item>\nclass ConcreteAggregate : public Aggregate<Item>\n{\npublic:\n　ConcreteAggregate()\n　{\n　　data.push_back(1);\n　　data.push_back(2);\n　　data.push_back(3);\n　}\n\n　virtual Iterator<Item>* createIterator()\n　{\n　　return new ConcreteIterator<Item>(this);\n　}\n\n　Item& operator[](int index)\n　{\n　　return data[index];\n　}\n\n　int getLen()\n　{\n　　return data.size();\n　}\n\nprivate:\n　vector<Item> data;\n};\n\nint main()\n{\n　Aggregate<int> *aggr = new ConcreteAggregate<int>();\n　Iterator<int> *it = aggr->createIterator();\n\n　for(it->first(); !it->isDone(); it->next())\n　{\n　　cout << *(it->currentItem()) << endl;\n　}\n　\n　delete it;\n　delete aggr;\n　\n　return 0;\n}\n\n```\n\n\n\n\n","tags":["设计模式"]},{"title":"张学良的1936年","url":"/2019/04/14/张学良的1936年/","content":"\n　离开台湾前的最后一个礼拜，拜访了张学良在新竹清泉山中的的故居，少帅迁来台湾后，一直被蒋介石囚禁在此，这次离职后回到西安这个曾经居住了4年多的城市，特意参观了张学良在西安的公馆，少帅就是在这里策划了“西安事变”，从西安到台湾，记录了自己人生中很重要的一段旅程，很巧合的是，这也正是张学良曾经人生的轨迹，只是少帅的人生划出一道绚烂的曲线，却像流星一样，消失在苍穹之中\n\n![](/img/随笔/张学良_01.jpg)\n　（台湾新竹的张学良故居）\n\n　张学良晚年曾说“自己的生命其实早就结束了，三十五岁那一年就结束了”，张学良的三十五岁那一年，其实就是1936年，这一年的12月，张学良发动了震惊中外的“西安事变”，历史毕竟是后人讲出来的，两岸也都爱讲“西安事变”，有人越讲越有味，有人越讲越变味，讲了八十年，早就已经串了味...2001年，重获自由的张学良在夏威夷檀香山与世长辞，享年一百零一岁，曾经国民党书本里的乱臣贼子，中共眼中的千古功臣，至死也再也没回忆澄清过“西安事变”，任其成了历史上的罗生门\n\n　把时间拨回到回到八十年前，1936年12月12日，张学良软禁了蒋介石，打出口号“停止内战，一致抗日”，然而这两句空泛的口号仅仅只是外因，这样的外因显然并不足以让张学良做出如此极端的选择，真正的内因，更合理的解释恐怕是张学良自己的性格，从小在张作霖的溺爱中长大，张学良从没有受过挫折，成长过程中一帆风顺的命运宠坏了他，在他的性格中留下了至死都无法摆脱的自负，虚荣，还有脆弱的自尊心，只是风华当年的少帅怎么也不会想到，这些最终会酿成自己一生的悲剧\n\n　如果没有“西安事变”，1936年在历史上很可能会被人遗忘，确实这一年的大多数时间都很平淡，好像历史在这一年要打个瞌睡，不过很多事情就像地壳运动，发生在很深很深的地表之下，而并不能被人们所轻易察觉，但是影响却很深远，终有一天，积聚的能量会像火山一样喷发，造成最意想不到的剧烈后果\n\n　1936年初，收拾完各个政敌和军阀的蒋介石环顾中华大地，自己的地盘上似乎不会再有谁能掀起大浪了，而当时的日本，也已经有两年多没有大动作，最后的心腹大患红军，刚刚结束了长征，被赶到陕西，兵力已经不足一万，而且迅速陷入了重兵合围，此时的红军被压缩在陕北几个贫瘠的县，南边有杨虎城的6万西北军，北边是汤恩伯和高桂滋的4个师，东面是阎锡山的10万晋绥军，西边则是宁夏五马的地盘，外围还有胡宗南的中央军虎视眈眈，加起来的兵力总和甚至超过了解放区的老百姓数量，陕北土地贫瘠，气候恶劣，几乎没什么资源，也没有任何工业基础，似乎光是封锁就能饿死红军，在蒋介石看来，红军的灭亡已经是指日可待\n\n　面对已经是瓮中之鳖的红军，蒋介石脑中很快形成了一个一斧三砍的计划，他想到了“九一八”丢失东北的张学良和16万东北军，蒋介石委以张学良消灭红军的任务，并且许诺给了张学良西北的地盘，其实意在让红军和非黄埔嫡系的西北军和东北军三股势力相互消耗，心怀“西北王”抱负的张学良初到陕西，意气风发，以十几万装备精良的东北军优势兵力，对付刚刚经历完长征，看上去已是强弩之末的红军，张学良觉得结果毫无悬念，似乎自己就是来接手地盘的，但是局势的发展很快就出乎张学良的意料，对红军的第一战东北军折损了两个师，接下来的战斗中，东北军屡战屡败，明明已经快弹尽粮绝的红军，似乎突然就有了用不完的子弹，屡屡创造战争奇迹，愈打愈勇，其实不管怎样的奇迹总是有原因的，红军的勇猛背后，隐隐约约闪烁着杨虎城的影子，早在3年前的1933年，张国焘领导的红四方面军刚刚建立川陕革命根据地，杨虎城就派人联系，表达了和平共处的愿望，西北军和红军签了一份秘密协议“汉中协定”，这个协议有两层意思，第一层是双方和平共处，第二层意思有点让人吃惊，如果红军去攻击胡宗南的中央军，西北军不但提供弹药支持，还掩护红军的侧后方，实际上这份条约让西北军和红四方面军已经结成了军事同盟，作为军阀之一的杨虎城和中共签订这个密约其实也不难理解，和红军的火拼必然造成两败俱伤，让蒋介石渔翁得利，只要有蒋介石这只大老虎在旁边蹲着，杨虎城仅仅不打红军是不够的，还要把红军养肥，养寇自重，红军的安全实际上就等于了杨虎城的安全，因此用红军这杆最好的枪去打蒋介石，就成了杨虎城最聪明的选择\n\n　历史学家们往往只注重分析客观因素，而忽略了一些主观的感受，历史人物也是人，也有七情六欲，有些人可以隐藏的很好，把内心澎湃的情感服服帖帖的压在一表斯文之下，这种人是成熟的政客，但张学良恰恰是个反例，年轻的少帅往往意气用事，蒋介石和张学良结拜之后，长兄如父，蒋介石往往长辈自居，更要命的是，军人出身的蒋介石对自己亲近的人，往往也是很严格，刚相识的时候两人多少有些生分，蒋介石勉励多于教训，而随着时间的推移，这种生分就渐渐消失了，刚好这时张学良在军事上又栽了跟头，而这些军事上的不利，就成了张学良失去面子的开端，不过这时还只是张学良噩梦的开始，完全没有意识到风暴已经悄悄向自己扑来，一出悲剧已经拉开了大幕，不可避免，对红军战斗中一连串的失败，终于引发了张学良最不愿意看到的事情，蒋介石的话越说越重，甚至开始了直接的责骂，对于张学良来说，蒋介石的管教过于严厉了，对于一个习惯了仰慕，看惯了笑脸的人，面子当然是最重要的，面子的丧失也就是怨恨的开始，一面是不想打也打不过的红军，一面是蒋介石剿共的压力，这种情况之下，张学良仿佛陷入了一个死循环\n\n　而对于蒋介石和张学良之间日益扩大的裂痕，敏锐的红军领导层却嗅出了另一种可能性，试着向张学良伸出橄榄枝，红军领导层对于说服张学良，开始并没有报以太大的希望，可是没想到已经陷入了人生低谷期的张学良，居然痛快答应了和谈的要求，两个难兄难弟很快就走到了一起\n\n　1936年4月9日，张学良和周恩来见面了，这次会谈似乎从来没有被给予过足够的重视，但是正是这次会谈，却很可能影响了中国未来的走向，是“西安事变”的直接诱因，这次会谈，作为20世纪最伟大的外交家，长袖善舞的周恩来充分展示了自己的外交才华，而张学良也充分证明了自己的年轻冲动，洞察张学良性格弱点的周恩来充分表达了对张学良的尊重，在交谈中不断捧高张学良，真正的强者往往低调，不去计较面子上的得失，尤其在蛰伏的时候，更加不吝啬给别人戴高帽，周恩来甚至表示，未来将在苏联的支持下，由西北的各股军事势力组建西北联军，并且组建西北联合政府，红军愿意接受张学良的领导，而且可以得到苏联的军事支援，这种论调让张学良找回了久违的面子，一个虚妄的憧憬在张学良心中产生了 —— 西北联军总司令，西北联合政府领导人，加上苏联的援助，自己甚至可以打回东北，跟蒋介石分庭抗礼\n\n![](/img/随笔/张学良_02.jpg)\n　（周恩来致张学良的信）\n\n　不久后的6月1日，“两广事变”爆发了，两广的粤桂两系，联合通电，要求“停止内战，一致抗日”，和后来的“西安事变”一模一样的口号，潜台词就是要求蒋介石的中央军停止对地方势力的进逼，多个小势力在一个大势力的压迫之下，大家打出的算盘其实是一样的，这时最正常不过的自保方式，就是在日本人打进来的时候，利用舆论，来打击蒋介石的“攘外安内”政策，这样的手段显然并不是只有红军想到了，其实每一个受到蒋介石胁迫的军政势力都想到了，“两广事变”让各地军阀势力开始暗流涌动，被煽动起来的学生群众也都纷纷组织抗日游行，一时间，蒋介石就处在了舆论的被动局面上，不过熟稔各种政治手段的蒋介石仅仅打出了“封官”和“利诱”两张牌就直接瓦解了粤军主力，整个“两广事变”蒋介石处理的相当精彩，根本没给其他势力留下什么机会\n\n　1936年下半年，处理完“两广事变”的蒋介石终于腾出手来，命令胡宗南的中央军对陕北的红军展开最大力度的打击，仅仅两三个月之内，红军被打的苟延馋喘，随时都有被胡宗南消灭的可能，而这时蒋介石对张学良已经渐渐开始失望，张学良跟蒋介石关系也逐渐恶化，随时都有崩溃的可能\n\n　1936年12月2日，蒋介石电令中央军往陕西方向调动，准备一鼓作气消灭红军，速度之快出乎了张学良和杨虎城的意料，西北联合政府和苏联援助成了张学良唯一的指望，这个梦，无论如何不能破灭了，不然自己的政治生命，恐怕也就到头了\n\n![](/img/随笔/张学良_03.jpg)\n　（西安市张公馆，张学良在此策划了西安事变）\n\n　12月12日，大家熟知的“西安事变”终于爆发了，可是接下来的一幕幕，却完全出乎了张学良的意料，首先，苏联公开谴责，甚至在苏共机关报《真理报》上明确反对，第二，舆论界和大部分知识分子，不分左派右派，集体声讨，而且口号鲜明，直指张学良“假抗日 真叛国”，舆论的一边倒给张学良造成了极大的心理负担，第三，各路军阀不支持，在国内国际的形势之下，没有人想碰这个烫手的山芋，第四，南京政府空前团结，态度强硬，南京政府的飞机在西安上空盘旋示威，部队也向潼关挺进...当历史的车轮毫不留情的向自己碾压的时候，张学良终于绝望了...\n\n　张学良并不是一个合格的军事家，更谈不上是一个称职的政治家，他身上强烈的虚荣天性严重屏蔽了他的政治理性，而脆弱的自尊心又把他在逆境中的坚韧性和抗挫折能力摧毁殆尽，这一切共同驱使他最终走上了失败和灭亡的道路，就像莎士比亚笔下的一个故事，一个人的性格弱点，在复杂的环境里面，被利用，被激发，最后无力自拔，坠入命运的深渊，一切都好像是注定的一般，也确实是被注定的，因为性格决定命运，只是对于注定要在历史上留下浓重一笔的人来说，性格决定的，不单单是自己的命运，甚至左右了国家的前途\n　\n![](/img/随笔/张学良_04.jpg)\n　（台湾新竹的张学良故居）\n\n　再次把时光倒回到八十年前，那是一个一切皆有可能的时代，天堂和地狱或许只在一念之间，贵贱，生死，荣辱，成败，得失...这些貌似矛盾对立的两极，往往在一个阴差阳错的瞬间就已经相互易位，迅捷如闪电，而一个人，能在短暂如烟过眼的一生中，经历什么叫做星移物换，沧海桑田，也能在某个刀光闪过的短暂一秒中，见证什么叫做人生如梦，刹那永恒\n\n　所以那也是一个一着不慎、满盘皆输的时代，历史的大棋盘乍一看风起云涌，龙盘虎踞，可就在不经意的回眸之间，一切都已尘埃落定，张学良命运的弈局开场时精彩无比，少帅曾经自以为手段精妙，纵然走不出吞吐天下的乾坤步，至少也能搏一个逍遥一方的玲珑局，可惜英雄气短，一步走来一步悔，到最后少帅或许会感伤，为什么没有人在开局时就告诫自己：\n\n　小心！落子无悔！\n\n\n","tags":["随笔"]},{"title":"Windows消息结构","url":"/2019/04/13/Windows消息结构/","content":"\n　Windows系统以消息为基础(message based)，以事件为驱动(event driven)，Windows应用程序的进行依靠发生的事件来驱动，事件最终会以消息的形式通知应用程序，因此Windows的消息结构体MSG是Windows系统中最基本、也是最重要的核心之一\n\n### Windows消息结构\n\n　Windows的消息结构体MSG完成声明如下(可查阅MSDN)：\n\n```\ntypedef struct tagMSG\n{\n　HWND hwnd;\n　UNIT message;\n　WPARAM wParam;\n　LPARAM lParam;\n　DWORD time;\n　POINT point;\n} MSG;\n```\n\n- HWND hwnd：表示接受该消息的窗口句柄\n\n- UNIT message：表示消息标识符(消息值)，message是MSG结构体中最重要的成员，也是MSG结构体的核心\n\n\t所有窗口消息定义为具有指定值的宏，用 `WM_` 作为前缀，前缀之后是描述消息名，比如窗口重新确定尺寸的消息值为 `WM_SIZE(0x0005)`\n\n- WPARAM wParam & LPARAM lParam：都是32位的特定附加信息，wParam和lParam的确切含义取决于message消息值，message消息值不同，wParam和lParam表示的附加信息也就不同\n\n\twParam和lParam这两个成员的命名方式是Win16系统时代遗留下来的产物，在Win16 API中WndProc()有两个参数：一个是WORD类型的16位整型变量，另一个是LONG类型的32位整型变量，根据匈牙利命名法，16位的变量就被命名为wParam, 32位的变量就被命名为lParam，到了Win32系统时代中，原来的16位变量也被扩展为32位，因此现在wParam和lParam的大小完全相同\n\n- DWORD time：表示消息送至消息队列的时间\n\n- POINT point：表示消息发送时鼠标在屏幕坐标系中的位置，POINT为嵌套结构成员，他的定义如下：\n```\ntypedef struct tagPOINT\n{\n　LONG x;\n　LONG y;\n} POINT;\n```\n\n### Windows消息分类\n\n　以 `WM_USER` 和 `WM_APP` 两个预定义的宏为界，Windows消息范围可以分为以下几类：\n```\n#define WM_USER  0x0400 \n#define WM_APP  0x8000\n```\n\n- 系统预留消息( Messages reserved for use by the system )\n\n\t消息范围：0 ~ WM_USER – 1\n\n- 自定义窗口类消息( Integer messages for use by private window classes  )\n\n\t消息范围：WM_USER ~ WM_APP – 1\n\n- 应用程序自定义消息( Messages available for use by applications )\n\n\t消息范围：WM_APP ~ 0xBFFF\n\t\n- 应用程序字符串消息( String messages for use by applications )\n\n\t消息范围：0xC000 ~ 0xFFFF\n\t\n- 系统预留( Reserved by the system  )\n\n\t消息范围：0xFFFF ~\n\n### 常用Windows消息表\n\n- WM_CREATE( 0x0001 ): 创建一个窗口\n\n- WM_DESTROY( 0x0002 ): 销毁一个窗口\n\n- WM_SIZE( 0x0005 ): 改变一个窗口的大小\n\n- WM_PAINT( 0x000F ): 要求一个窗口重画自己\n\n- WM_NOTIFY( 0x004E ): 当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口\n\n- WM_KEYDOWN( 0x0100 ): 按下一个键\n\n- WM_KEYUP( 0x0101 ): 释放一个键\n\n- WM_COMMAND( 0x0111 ): 当用户选择一条菜单命令项或当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口\n\n- WM_TIMER( 0x0113 ): 发生了定时器事件\n\n- WM_HSCROLL( 0x0114 ): 当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件\n\n- WM_VSCROLL( 0x0115 ): 当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件\n\n- WM_MOUSEMOVE( 0x0200 ): 移动鼠标\n\n- WM_LBUTTONDOWN( 0x0201 ): 按下鼠标左键\n\n- WM_LBUTTONUP( 0x0202 ): 释放鼠标左键\n\n- WM_LBUTTONDBLCLK( 0x0203 ): 双击鼠标左键\n\n- WM_RBUTTONDOWN( 0x0204 ): 按下鼠标右键\n\n- WM_RBUTTONUP( 0x0205 ): 释放鼠标右键\n\n- WM_RBUTTONDBLCLK( 0x0206 ): 双击鼠标右键\n\n\n","tags":["Windows编程"]},{"title":"C++多态的原理和实现","url":"/2019/04/13/C++多态的原理和实现/","content":"\n　多态（polymorphism）源自希腊语，从字面上理解就是多种形态，多种形式，具体到C++这种面向对象（OOP）的语言中，其实就是“一种接口，多种实现（方法）”，是C++最重要的核心特性之一\n\n### 什么是多态？\n\n　C++中多态并不仅仅是单一的一种技术，而是多种技术的合称，多态可分为**静态多态**和**动态多态**，具体的分类情况如下：\n\n![](/img/C++/Polymorphism.png)\n\n　**静态多态**和**动态多态**的关键区别是函数实现和函数调用关联起来的时间点，是在编译时期还是运行时期，也就是函数地址是**早绑定**还是**晚绑定**\n\n- **静态多态**是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是**早绑定**，静态多态也往往被叫做**静态联编**，通过**泛型编程**和**函数重载**两种方式都可以实现静态多态\n\n```\n// 泛型编程(函数模板)\ntemplate <typename T>   // typename也可以替换为class\nT add(T a, T b)\n{\n　return a + b;\n}\n```\n\n```\n// 函数重载\nint add(int a, int b)\n{\n　return a + b;\n}\n\ndouble add(double a, double b)\n{\n　return a + b;\n}\n```\n\n- **动态多态**则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于**晚绑定**，动态多态也往往被叫做**动态联编**\n\n　静态多态的原理与实现比较容易理解，下面主要讨论动态多态的原理与实现\n\n### 为什么要使用多态？\n\n　C++有封装、继承、多态三大特性，封装可以使得代码模块化，继承可以在原有的代码基础上扩展，继承是为了代码重用，而多态是为了接口重用，不论传递过来的究竟是哪个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法\n\n- 首先看一段代码：\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　\n　b.fun();   // 调用基类的fun(),打印Base::fun()\n　d.fun();   // 子类继承了基类的fun()且子类本身没有fun(),因此此处还是调用基类的fun(),打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 在子类中重定义(隐藏)fun()函数，再看这段代码：\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　\n　b.fun();   // 调用基类的fun(),打印Base::fun()\n　// 子类虽然继承了基类的fun(),但是子类本身中fun()\n　// 此时构成了重定义,基类中的fun()被隐藏，调用的是子类的fun()\n　// 打印Derived::fun()\n　d.fun();\n　d.Base::fun();   // 加类的作用域限定符,调用基类的fun(),打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 保持上面这段代码的类定义不变，用类指针类调用成员函数，分析执行结果发现，基类指针指向子类，却调用基类自己的fun函数打印Base::fun()，而不是子类的Derived::fun()，这就是因为上面讲的静态联编，其实在编译时期就将函数实现和函数调用关联起来，指针在编译时期是Base类的，自然调用Base类的fun()\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　Base *pb = &b;\n　Derived *pd = &d;\n　\n　pb->fun();   // pb指向基类,打印Base::fun()\n　pd->fun();   // pb指向子类,打印Derived::fun()\n　\n　pb = &d;   // 将基类指针指向子类\n　pb->fun();   // pb指向子类,却打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 为了避免上一段代码中的这种情况，C++中引入了动态多态，通过**继承**和**虚函数**来实现，在程序运行期间(非编译期)判断所指针指向对象的实际类型，根据其实际类型调用相应的方法，具体格式就是使用**virtual关键字**修饰类的成员函数，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定，以下为用虚函数实现的代码\n\n```\nclass Base\n{\npublic:\n　virtual void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　Base *pb = &b;\n　Derived *pd = &d;\n　\n　pb->fun();   // pb指向基类,打印Base::fun()\n　pd->fun();   // pb指向子类,打印Derived::fun()\n　\n　pb = &d;   // 将基类指针指向子类\n　pb->fun();   // pb实际指向子类,打印Derived::fun()\n　\n　return 0;\n}\n```\n\n　动态多态的实现有两个必要的绑定条件：\n\n- 必须在基类中定义虚函数\n- 必须通过基类类型的引用或者指针调用虚函数\n\n### 多态怎么实现？\n\n　C++通过继承和虚函数来实现多态，编译器在编译的时候，会为每个包含虚函数的类创建一个虚表(vtable)，在虚表中存放每个虚函数的地址，编译器另外还为每个对象提供了一个虚表指针(vptr)，这个指针指向了对象所属类的vtable，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的vtable，从而在调用虚函数的时候，能够找到正确的函数\n\n![](/img/C++/vtable.png)\n\n　由于每个对象调用的虚函数都是通过vptr来索引的，因此vptr的正确初始化是非常重要的，在vptr没有正确初始化之前，不能够去调用虚函数，C++在类的构造函数中进行vtable的创建和vptr的初始化，在构造子类对象时，要先调用父类的构造函数，初始化父类对象的vptr，此时vptr指向父类的vtbale，当执行子类的构造函数时，子类对象的vptr被初始化，指向子类的vtbale\n\n\n","tags":["C++"]},{"title":"单例(Singleton)模式","url":"/2019/04/12/单例(Singleton)模式/","content":"\n　对于具有一定开发经验的程序员，几乎都在项目中使用或者接触过单例模式，单例模式是软件设计模式中最常用的模式之一\n\n　在计算机系统中，线程池、缓存、日志对象、打印机、显卡的驱动程序对象等常被设计成单例实现，这些应用都或多或少具有资源管理器的功能，比如每台计算机一定只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中，选择单例模式就是为了避免不一致状态，避免发生冲突\n\n### 单例模式的定义\n\n　单例模式涉及到一个单一的类(单例类)，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象，可以概括为以下三点：\n\n- 单例类只能有一个实例\n\n- 单例类必须自己创建自己的唯一实例\n\n- 单例类必须给所有其他对象提供这一实例的访问方式\n\n![](/img/DesignPattern/Singleton.jpg)\n\n### 单例模式的代码实现(C++)\n\n　单例模式有两种实现方式 —— 懒汉方式和饿汉方式：　\n\n- 懒汉方式：在第一次用到类实例的时候才会去实例化，访问线程比较少时，可使用懒汉方式，用时间换空间\n\n```\n// 单例模式的懒汉方式实现\n// 为了保证线程安全，需要加锁\n\nclass Singleton\n{\nprotected:\n　Singleton();\npublic:\n　static pthread_mutex_t mutex;\n　static Singleton* GetInstance();\nprivate:\n　static Singleton* p;\n}\n\npthread_mutex_t Singleton::mutex;\nSingleton* Singleton::p = NULL;\n\nSingleton::Singleton()\n{\n　pthread_mutex_init(&mutex);\n}\n\nSingleton* Singleton::GetInstance()\n{\n　if( p == NULL)\n　{\n　　pthread_mutex_lock(&mutex);\n　　p = new Singleton();\n　　pthread_mutex_lock(&mutex);\n　}\n　\n　return p;\n}\n\n```\n\n- 饿汉方式：单例类定义的时候就进行实例化，访问线程比较多时，可使用饿汉方式，用空间换时间\n\n```\n// 单例模式的饿汉方式实现\n// 饿汉方式本身就是线程安全的\n\nclass Singleton\n{\nprotected:\n　Singleton() {}\npublic:\n　static Singleton* GetInstance();\nprivate:\n　static Singleton* p;\n}\n\nSingleton* Singleton::p = Singleton();\n\nSingleton* Singleton::GetInstance()\n{\n　return p;\n}\n\n```\n\n\n\n","tags":["设计模式"]},{"title":"C++关键字用法总结","url":"/2019/04/12/C++关键字用法总结/","content":"\n### 关键字extern\n\n　C++支持分离式编译机制，一个完整的程序或项目可以分割为若干个.cpp源文件，每个.cpp源文件单独编译生成.obj目标文件，最后将所有.obj目标文件链接成一个单一的可执行文件，如果一个.cpp源文件要使用另一个.cpp源文件定义的变量，应该如何调用？\n　**C++中解决方法是将 `变量声明` 与 `变量定义` 分离**\n\n　`变量声明` 规定了变量的类型和名字，但仅仅只是告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存，使得名字为本程序文件所知道，比如一个文件如果想使用在另外一个文件中定义的变量，则必须包含对那个变量名字的声明，关键字extern就被用来实现 `变量声明`\n\n　`变量定义` 同样规定了变量的类型和名字，不同于 `变量声明` 的是，`变量定义` 还会给变量申请存储空间，还可能给变量赋予一个初始值，如果多个文件中都定义了同一个变量，编译时会产生变量重定义冲突错误\n\n\t```\n\textern int i;   // 变量声明\n\tint j;   // 变量定义\n\t\n\t// 需要注意!\n\t// 任何一个显式初始化的声明都将成为定义，而不管有没有extern\n\textern double pi = 3.1415926;\n\t```\n\n　关键字extern主要有以下三种使用方法：\n\n- 引用同一个文件中的变量\n\n```\n#include <stdio.h>\n\nint func();\n\nint main()\n{\n　func();\n　extern int num;   // 引用同一个文件中的变量\n　printf(\"%d\", num);\n　\n　return 0;\n}\n\nint num = 3;\n\nint func()\n{\n　printf(\"%d\\n\",num);\n}\n```\n\n- 引用另一个文件中的变量\n\n```\n// main.cpp\n\n#include <stdio.h>\n\nint main()\n{\n　extern int num;   // 引用另一个文件中的变量\n　printf(\"%d\",num);\n　\n　return 0;\n}\n```\n\n```\n// branch.cpp\n\n#include <stdio.h>\n\nint num = 5;\n```\n\n- 引用另一个文件中的函数\n\n```\n// main.cpp\n\n#include <stdio.h>\n\nint main()\n{\n　extern void func();   // 引用另一个文件中的函数\n　func();\n　\n　return 0;\n}\n```\n\n```\n// branch.cpp\n\n#include <stdio.h>\n\nvoid func()\n{\n　printf(\"func\");\n}\n```\n\n### 关键字const\n\n- const定义的常量，不能被修改；\n\n```\nconst int a;\n```\n\n- const修饰函数参数，防止被意外修改；\n\n```\nvoid func(const int a);\n```\n\n- const修饰函数返回值，则返回值不能被直接修改，且只能赋值给const修饰的同类变量；\n\n```\nconst int x = const int func(const int a);\n```\n\n- const修饰类成员变量，只能在定义的时候进行初始化，并且在程序的执行过程中不能被再次赋值；\n\n- const修饰类成员函数，放在类成员函数声明之后，保证不会修改该对象的成员变量\n\n```\nvoid fun(int val) const;\n// 任何不会修改类成员变量的类成员函数都应该使用const修饰\n// const成员函数不能调用非const成员函数\n```\n\n### 关键字static（面向过程）\n\n　关键字static的作用主要可以分为两方面，一方面是面向过程，另一方面是面向对象，先介绍面向过程：\n\n- **静态全局变量**\n\n　在全局变量前加上关键字static，该变量就被定义为静态全局变量，静态全局变量在全局/静态存储区初始化，作用域仅限于定义的文件，具有内部链接性\n\n- **静态局部变量**\n\n　在代码块中定义的变量前加上关键字static，该变量就被定义为静态局部变量，他始终驻留在全局/静态存储区，直到程序运行结束\n\n- **静态函数**\n\n　静态函数的声明方法也是在函数前加上关键字static，作用域仅限于定义的文件，不能被其他文件引用，不会发生冲突\n\n### 关键字static（面向对象）\n\n- **静态成员变量**\n\n　对于非静态成员变量，每个类对象都有自己的拷贝，而静态成员变量只有一份拷贝，存在于全局/静态存储区，由该类型的所有对象共享，静态成员变量定义时要分配空间，所以不能在类声明中定义，只能在类外定义\n\n- **静态成员函数**\n\n　普通成员函数一般都隐藏了一个this指针，this指针指向类对象本身，因为普通成员函数总是具体的属于某个类的具体对象的，而静态成员函数不具有this指针，因此他无法访问属于类对象的非静态成员变量，也无法访问非静态成员函数\n\n　一切不需要实例化就可以有确定行为方式的函数都应该设计成静态的，比如封装一些算法，或者实现一些设计模式\n\n### 关键字virtual\n\n 类的多态特性是支持面向对象的语言最主要的特性，C++中的关键字virtual是实现多态的重要方式\n\n- 虚函数\n　虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数\n\n- 纯虚函数\n　在基类中不对虚函数给出实现，把它声明为纯虚函数，它的实现留给该基类的派生类去完成，含有纯虚函数的类构成抽象类\n\n- 虚继承\n　在派生类继承基类时，加上一个virtual关键词则为虚拟基类继承，虚继承主要用于一个类继承多个类的情况，避免重复继承同一个类两次或多次\n\n### 关键字struct\n\n　在C语言中，struct用来定义一个结构体，仅仅是一个包含不同数据类型的数据结构，C++中的struct对C语言中的struct进行了扩充，C++中的struct结构体能包含成员函数，能继承，也能实现多态，其实已经几乎实现了class的功能，在C++中struct和class的区别主要是以下两点\n\n- struct的默认的继承访问权限是public，而class是private\n\n- struct的默认的数据访问控制是public，而class是private\n\n### 关键字inline\n\n　inline关键字修饰的函数称为“内联函数”，内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样\n\n　函数调用语句和直接把函数中的代码重新抄写一遍相比，带来了程序运行时间上的额外开销，一般情况下，这个开销可以忽略不计，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了，假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢\n\n### 作用域运算符::\n\n　作用域运算符::是运算符中等级最高的，可以分成三种：\n\n- 全局作用域符\n\n　当全局变量在某个局部作用中与其中某个局部变量重名，那么就可以用全局作用域符::来区分\n\t\n\t```\n\tint x = 1;   // 全局变量\n\t\n\tvoid func()\n\t{ \n\t　int x = 1;   // 局部变量\n\t　x = x + x;   // 局部变量，代码块中局部变量会覆盖全局变量\n\t　::x = ::x + x;   // 前两个x为全局变量，最后的x为局部变量\n\t}\n\t```\n\n- 类作用域符\n\n　为了避免不同的类有名称相同的成员，可以用类作用域符进行区分，类作用域符前面是类的名称，后面是该类的成员名称\n\n\t```\n\tclass A\n\t{\n\tpublic:\n\t　void func();\n\t}\n\t\n\tclass B\n\t{\n\tpublic:\n\t　void func();\n\t}\n\t\n\tvoid A::func()\n\t{\n\t　// ...\n\t}\n\t\n\tvoid B::func()\n\t{\n\t　// ...\n\t}\n\t```\n\n- 命名空间作用域符\n\n　命名空间作用域符可以区分不同命名空间中的成员，命名空间作用域符前面是命名空间的名称，后面是该命名空间的成员名称\n\n\t```\n\t#include <iostream>\n\tusing namespace std;\n\t\n\tnamespace A\n\t{\n\t　int x = 1;\n\t　\n\t　void fun()\n\t　{\n\t　　cout << \"A\" << endl;\n\t　}\n\t}\n\t\n\tnamespace B\n\t{\n\t　int x = 2;\n\t　\n\t　void fun()\n\t　{\n\t　　cout << \"B\" << endl;\n\t　}\n\t　\n\t　void fun2()\n\t　{\n\t　　cout << \"BB\" << endl;\n\t　}\n\t}\n\t\n\tint main()\n\t{\n\t　cout << A::x << endl;\n\t　cout << B::x << endl;\n\t\n\t　using namespace B;\n\t\n\t　A::fun();\n\t　fun();\n\t　fun2();\n\t　\n\t　return 0;\n\t}\n\t```\n\n","tags":["C++"]},{"title":"C++的内存分配和链接性","url":"/2019/04/11/C++的内存分配和链接性/","content":"\n　C++程序（包括其他语言的程序）由代码和数据两部分组成，代码存储在代码区中，数据根据类型的不同存储在不同的内存区域中，下面介绍内存区域的划分\n\n### C++的内存分配\n\n- **栈(stack)：**\n\n\t由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区，栈通常存储局部变量、函数参数等，在一个进程中，位于用户虚拟地址空间顶部的是栈，栈的地址向下生长\n\n- **堆(heap)：**\n\n\t由new分配的内存块存储区，堆中内存块的释放编译器不会检查，需要在代码中自己控制，一般一个new就需要对应一个delete，如果没有delete，会造成内存泄漏，在应用程序结束后，会自动回收\n\n- **自由存储区：**\n\n\t由malloc分配的内存块存储区，由free来回收，和堆的作用很类似\n\n- **全局/静态存储区：**\n\n\t全局变量和静态变量的存储区，在C语言中，全局变量和静态变量分为初始化的和未初始化的，未初始化的全局变量和静态变量会被用0来填充，存储在全局/静态存储区中的BSS(Block Started by Symbol)数据段，已经初始化的变量放在相邻的另一个数据段，在C++中已经没有这个区分，初始化的和未初始化的变量都共享同一块内存区\n\n- **常量存储区：**\n\n\t专门用来存放常量的存储区\n\n下面的代码显示了不同类型变量的存储方式：\n\n```\n#include <iostream>\nusing namespace std;\n\nconst int aa = 1;   // 常量存储区\n\nint bb = 2;   // 全局/静态存储区\nstatic int cc = 3;   // 全局/静态存储区\n\nint dd;   // 全局/静态存储区\nstatic int ee;   // 全局/静态存储区\n\nint main()\n{\n　int a;   // 栈(stack)\n　int b;   // 栈(stack)\n\n　static int c = 0;   // 全局/静态存储区\n　static int d;   // 全局/静态存储区\n\n　int *p = new int[5];   // 堆(heap)\n　delete []p;   // 一定要释放，否则会造成内存泄漏\n    \n　return 0;\n}\n```\n\n### 堆和栈的区别\n\n- **管理方式：**\n\n\t栈由编译器自动管理，无需手动控制；\n\t堆由new/delete来控制，申请后没有释放内存容易造成memory leak；\n\n- **空间大小：**\n\n\t一般在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的；\n\t对于栈来讲，一般都是有一定的空间大小的，例如在VC6下面，默认的栈空间大小是1M，也可以在工程中修改栈的大小；\n\n- **碎片问题：**\n\n\t频繁的new/delete势必会造成堆内存空间的不连续，从而造成大量的碎片；\n\t而栈则不存在这个问题；\n\n- **生长方向：**\n\n\t栈的生长方向是向下的，是向着内存地址减小的方向增长；\n\t堆的生长方向是向上的，也就是向着内存地址增加的方向；\n\n- **分配方式：**\n\n\t堆都是动态分配的，没有静态分配的堆；\n\t栈有静态分配和动态分配2种分配方式，都由编译器实现；\n\n- **分配效率：**\n\n\t计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，栈的分配效率比较高；\n\t而堆的分配效率比较低；\n\n### C++的链接性\n\n　C++栈中存储的自动变量一定是无链接性的，而全局/静态存储区存储的静态变量按照链接性可以分为三种，分别是：外部链接性，内部链接性和无链接性\n\n- **外部链接性：**\n\n\t外部链接性的静态变量在代码块之外声明，不带static，具有多文件作用域；\n\n- **内部链接性：**\n\n\t内部链接性的静态变量同样在代码块之外声明，用关键字static或者const修饰，作用域仅限于单文件；\n\n- **无链接性：**\n\n\t无链接性的静态变量在代码块中声明，用关键字static修饰，作用域仅限于声明的代码块中\n\n下面的代码显示了不同变量的链接性：\n\n```\n#include <iostream>\nusing namespace std;\n\nint x = 1;   // 声明外部链接性的变量\nstatic int y;    // 声明内部链接性的变量\n\nint func()\n{\n　static int z;   // 声明无链接的变量\n}\n\nint main()\n{\n　return 0;\n}\n```\n\n","tags":["C++"]},{"title":"理解Windows句柄","url":"/2019/04/10/理解Windows句柄/","content":"\n　开始Windows编程半年多，几乎每天都需要和各种Windows句柄打交道，一直把Windows句柄当做一个指针来使用，虽然在句柄的使用上没遇到问题，认识却停留在一知半解的层面，趁这段离职的时间，终于可以深入把Windows句柄理解清楚\n\n### 什么是Windows句柄\n\n　首先来看下微软自己对于句柄的定义：\n\n```\n《Microsoft Windows 3 Developer's Workshop》 (by Richard Wilton) [Microsoft Press]\n在Windows环境中，句柄是Windows系统用来标识被应用程序所建立或使用的对象的唯一整数\n这些对象包括：\n模块(module)、任务(task)、实例 (instance)、对话框(dialog)、文件(file)、\n内存块(block of memory)、菜单(menu)、控制(control)、字体(font)、\n资源(resource)[包括图标(icon)，光标 (cursor)，字符串(string)等]、\nGDI对象(GDI object)[包括位图(bitmap)，画刷(brush)，元文件（metafile），\n调色板(palette)，画笔(pen)，区域 (region)，以及设备描述表(device context)]\n```\n\n　数值上，句柄是一个32位的整数（32位系统下），逻辑上，句柄相当于指针的指针，实际上，句柄是Windows系统在内存中维护的一个对象（窗口等）内存物理地址列表的整数索引，是Windows中各个对象的一个唯一的、固定不变的ID（所谓“唯一”、“不变”是指在程序的一次运行过程中），通过句柄就可以找到对象在内存中的位置，从而去对内存中的对象进行操作\n　\n　注意句柄是对象生成时Windows系统指定分配的，属性是只读的，程序员不能修改句柄，程序员只能通过句柄调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事\n\n### 为什么需要Windows句柄\n\n　或许很多人会问，既然句柄的作用相当于指针，干脆直接获取对象在内存中的首地址，不就可以随时用这个地址访问对象了，为什么还需要通过句柄找到指针多此一举？\n\n　其实这样在Windows系统中行不通！\n\n　Windows系统是一个以虚拟内存为基础的操作系统，很多时候进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被替换出内存，当再次需要时，再装入内存，两次装入的地址基本上是不一样的，也就是说，同一对象在内存中的地址会变化，那么程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄\n\n　Windows系统为每个进程在内存中分配一定的空间，用来存放各个句柄，即各个32位无符号整型值（32位系统下），每个32位无符号整型值相当于一个指针，指向内存中的一个区域，而区域中存放的正是对象在内存中的地址，当对象在内存中的位置发生变化时，区域中存放的值被更新，变为当前时间点对象在内存中的地址，而在这个过程中，区域的位置以及对应句柄的值是不发生变化的，这个过程机制用下面的2张图来形象展示\n\n- 图1：程序运行到某时间点的内存快照\n\n![](/img/Windows/HANDLE_01.png)\n\n- 图2：程序往后运行到另一时刻时的内存快照，对象在内存中的位置已经发生变化，而区域的位置以及对应句柄的值没有发生变化\n\n![](/img/Windows/HANDLE_02.png)\n\n　通过这2张图就明白了句柄的作用：有一个固定的标识（句柄），指向一个固定的位置（区域），而区域中存放的值可以动态地变化（虚拟内存），他时刻记录着当前时间点对象在内存中的地址，这样无论对象的位置在内存中如何变化，只要掌握了句柄的值，就可以找到区域，进而找到该对象进行操作\n\n### 从源代码分析Windows句柄\n\n　在WinNT.h中，定义了大部分Windows系统里一些内部结构，包括通用句柄的结构\n\n```\ntypedef void *PVOID;\n \n#ifdef STRICT\ntypedef void *HANDLE;\n#define DECLARE_HANDLE(name) struct name##__ { int unused;};\ntypedef struct name##__ *name\n#else\ntypedef PVOID HANDLE;\n#define DECLARE_HANDLE(name) typedef HANDLE name\n#endif\n```\n\n　在Windef.h中做了特殊句柄的定义\n\n```\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HFONT);\n#endif\nDECLARE_HANDLE(HICON);\n#if !defined(_MAC) || !defined(WIN_INTERNAL)\nDECLARE_HANDLE(HMENU);\n#endif\nDECLARE_HANDLE(HMETAFILE);\nDECLARE_HANDLE(HINSTANCE);\ntypedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HPALETTE);\nDECLARE_HANDLE(HPEN);\n#endif\nDECLARE_HANDLE(HRGN);\nDECLARE_HANDLE(HRSRC);\nDECLARE_HANDLE(HSTR);\nDECLARE_HANDLE(HTASK);\nDECLARE_HANDLE(HWINSTA);\nDECLARE_HANDLE(HKL);\n```\n\n　微软把通用句柄HANDLE定义为void指针，显然是不想让人知道句柄的真实类型，但是通过分析代码可以发现，句柄就是一种指向结构体的指针，由于指向结构体指针可以强制截断只获取第一个字段，这里的struct结构体绝对不止一个字段，但是可以很容易猜到结构体的第一个字段就是逻辑地址（指针）\n\n### 窗口句柄和窗口指针\n\n　窗口对象是一个继承于CWnd类的C++类的对象，是Windows编程中最常用的对象，窗口句柄和窗口指针可以通过对方来相互获取\n\n- 从窗口指针获取窗口句柄\n\n```\nHWND hWnd;\nhWnd = GetDlgItem(IDC_STATIC_WND)->GetSafeHwnd();\n```\n\n- 从窗口句柄获取窗口指针\n\n```\n// HBITMAP m_hBitmap\nCBitmap *pBitmap = FromHandle(m_hBitmap);\n```\n\n\n","tags":["Windows编程"]},{"title":"从函数指针到回调函数","url":"/2019/04/09/从函数指针到回调函数/","content":"\n\n　C++(包括C语言)中最灵活的技术就是指针，在操作一个对象或者数组时，我们常常用到指针，可以给编程带来很多灵活性，而指针不仅仅能指向对象或者固定数据类型，还可以指向函数，这就是函数指针\n\n　有了函数指针，我们可以通过指针调用函数，更重要的是我们可以将函数指针作为参数传递给函数，进而可以实现回调函数(callback)功能，所以有了函数指针，我们的程序可以设计的更加灵活，这也正是C++的魅力(当然指针是一把双刃剑，使用不当也会引发灾难:)\n\n## 函数指针\n\n### 函数指针的简单定义\n\n　C++中函数声明由3部分组成，分别是函数的参数、返回类型和函数名，其中参数和返回类型这两项决定了函数类型，函数类型与函数名无关，以下例子中函数类型为int(int)\n\n```\n// 函数声明\nint PrintInt(int i);\n\n// 函数定义\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n```\n\n　声明一个指向某种函数类型的函数指针非常简单，只需要用指针替换函数名即可，以下例子中声明了一个函数指针，可以指向函数类型为int(int)的函数，这里要注意，函数指针 `(*pFunc)` 两边的括号必不可少，否则声明的就不再是函数指针，而是返回值为(int *)型指针的函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 注意: pFunc不是函数指针，而是返回值为(int *)的函数\nint *pFunc(int i);\n```\n\n　声明函数指针完成后，函数指针处于未初始化的状态，需要将函数地址赋值给函数指针，然后就可以通过函数指针来调用函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 将函数地址赋值给函数指针\n　pFunc = PrintInt;   // pFunc = &PrintInt; 也可以\n　\n　// 通过函数指针来调用函数\n　pFunc(1);   // (*pFunc)(1); 也可以\n　\n　return 0;\n}\n```\n\n　其实在声明和定义函数的时候，函数名就是一个函数指针，只不过是一个常量函数指针，而在声明函数指针的时候，声明的是一个变量函数指针\n\n### 函数指针的typedef定义\n\n　声明函数指针的格式为 `返回值 (*函数指针名)(参数列表)`，每次需要声明一个函数指针的时候，都需要这样声明一长串显然很麻烦，可以用typedef关键字，定义某一种类型的函数指针，给它一个别名，然后用别名去声明函数指针就会像声明一个int型变量一样方便\n\n```\n// 使用typedef时，PTRFUNC不再是具体指针\n// PTRFUNC表示指向某种函数类型的函数指针类型 (拗口)\ntypedef int (*PTRFUNC)(int i);\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 通过PTRFUNC声明指针，并赋值\n　PTRFUNC pFunc = PrintInt;\n　\n　// 通过函数指针来调用函数\n　pFunc(1);\n　\n　return 0;\n}\n```\n\n### 函数指针作为函数的参数\n\n　有了函数指针，我们就可以像传递普通指针那样将一个函数作为参数传递给另一个函数，这大大的增加了我们编程的灵活性\n\n```\n// 定义int(int,int)类型的函数指针\ntypedef int (*CALLFUNC)(int,int);\n\n// CALLFUNC类型的函数作为参数\nvoid HandleFunc(CALLFUNC pFunc,int x,int y)\n{\n　cout << pFunc(x, y) << endl;\n}\n\n// 加法函数\nint AddFunc(int x,int y)\n{\n　return (x + y);\n}\n\n// 减法函数\nint SubFunc(int x,int y)\n{\n　return (x - y);\n}\n\nint main()\n{\n　// 将函数指针作为参数传递给函数\n　// &符号可以省略\n　HandleFunc(&AddFunc, 2, 1);\n　HandleFunc(&SubFunc, 2, 1);\n　\n　return 0;\n}\n```\n\n## 回调函数\n\n　掌握了函数指针，以及将函数指针作为参数进行传递的方法，我们就能实现函数指针最有用的功能 —— 回调函数(callback)\n\n　对于很多C++初学者来说，往往会觉得回调函数很神秘，其实要完全搞清楚回调函数只需要明白两个问题：\n\n> - 什么是回调函数？\n> \n> - 为什么要使用回调函数？\n\n### 什么是回调函数？\n\n　网上对于回调函数的定义五花八门，简而言之，回调函数就是一个通过函数指针调用的函数，如果你把函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数\n\n### 为什么要使用回调函数？\n\n　同样用一句话概括使用回调函数的最大作用，就是实现通知机制 (除此之外，回调函数还可以调用者和被调用者解耦)\n\n　关于调用普通函数和回调函数，我们用订蛋糕做个比喻，调用普通函数就好像你直接去蛋糕店订一个蛋糕，订完之后，你并不知道蛋糕什么时候会做好，所以你就需要一直在蛋糕店等着，一直到蛋糕做好了，才能取蛋糕；而回调函数就好像你去蛋糕店订一个蛋糕，这时蛋糕店会留下你的联系方式，当蛋糕做好了，蛋糕店就会给你打电话，让你去取蛋糕\n\n```\n### 调用普通函数 ###\n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　bool MakeCake();   // 做蛋糕函数，如果做好了返回true，否则返回false　\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n};\n\nBaker::Baker():m_iTime(0){}\n\nbool Baker::MakeCake()\n{\n　// 每次调用该函数，m_iTime+1\n　m_iTime += 1;\n　\n　if (m_iTime == m_iMaxTime)\n　{\n　　cout << \"蛋糕做好了!\" << endl;\n　　return true;\n　}\n　\n　return false;\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\t\n　// 做蛋糕\n　while(1)\n　{\n　　// 客户如果想第一时间知道蛋糕做没做好，就必须每时每刻查看蛋糕的情况\n　　if( baker.MakeCake() )\n　　{\n　　　GetMyCake();\n　　　break;\n　　}\n　　else\n　　{\n　　　cout << \"蛋糕没做好\" << endl;\n　　}\n　}\n\n　return 0;\n}\n```\n\n　我们如果想要第一时间知道蛋糕有没有做好，就必须一直查询蛋糕有没有做好，换句话说，我们不能去干别的事情，如果这是一个线程的话，那么这个线程在这段时间就不能做其他事情，至少不能100%专注做别的事情，因为必须保持关注蛋糕有没有做好，这显然很低效，而使用回调函数，就可以实现通知机制，大大提升效率\n\n```\n### 回调函数 ###\n\n// 声明回调函数\ntypedef void (*CALLBACKFUNC)(void);  \n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　void MakeCake();   // 做蛋糕函数\n　void Invoke(CALLBACKFUNC);   // 注册回调函数：留下订蛋糕的人的联系方式\n　void Notify();   // 通知订蛋糕的人\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n　CALLBACKFUNC m_pfCallBack;   // 回调函数\n};\n\nBaker::Baker():m_iTime(0){}\n\nvoid Baker::MakeCake()\n{\n　while(m_iTime < m_iMaxTime)\n　{\n　　// 每次调用该函数，m_iTime+1\n　　m_iTime += 1;\n　}\n　\n　cout << \"蛋糕做好了!\" << endl;\n　\n　Notify();\n}\n\nvoid Baker::Invoke(CALLBACKFUNC pFunc)\n{\n　m_pfCallBack = pFunc;\n　cout << \"留下了你的联系方式!\" << endl;\n}\n\nvoid Baker::Notify()\n{\n　if(m_pfCallBack)\n　　m_pfCallBack();\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\n　// 注册：留下联系方式\n　baker.Invoke(GetMyCake);\n　\n　// 注册之后，客户就不需要实时查询了\n　cout << \"好了请通知我!\" << endl;\n　\n　// 做蛋糕\n　baker.MakeCake();\n　\n　return 0;\n}\n```\n\n　在类中使用回调函数，先要注册回调函数，然后在某项任务完成以后，调用回调函数实现通知机制，比如我们做异步加载时，如果我们需要某个资源，就可以去加载线程注册一下，然后主线程继续做其他工作，加载线程加载完需要的资源之后，通过回调函数通知主线程，这样加载和主要功能就可以同时进行，大大的提升了用户体验\n\n\n","tags":["C++"]},{"title":"Hexo+GitHub搭建属于自己的Blog","url":"/2019/04/08/Hexo+GitHub搭建属于自己的Blog/","content":"\n　现在市面上可供程序猿们选择的博客已经有很多，如常见的CSDN，博客园和简书等等，然而这些平台有着各种各样的限制，各种不自由，加上烦人的小广告，让你的Blog看起来一点也不geek，一点都没“范儿”\n\n　有一些程序猿，包括我自己也尝试过搭建LNMP环境，用WordPress建站，但是这种方案的成本实在太高了，不光是服务器的购买成本，单单是去维护网站运行就需要花费不少精力，特别是对于LNMP架构不熟悉的人来说，Debug也常常很让人头疼\n\n　于是Hexo+GitHub成为了我选择的一种折中方案（也可以选择jekyll+GitHub的方案，实现类似），用Hexo作为一个快速简洁的博客框架，在GitHub Page平台上托管博客，可以非常方便省心的搭建起属于我们自己的博客\n\n## Hexo搭建\n　Hexo是一个基于Node.js的静态博客框架，安装依赖少，可以方便的生成静态网页，下面介绍macOS环境搭建Hexo的步骤:\n\n### 安装Node.js\n　Node是一个让JavaScript运行在服务端的开发平台，JavaScript是一门流行的前端语言，但是在2009年，国外开发者Ryan推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js，第一次把JavaScript带入到后端服务器开发，让Node一下子就火了起来\n\n　直接从Node.js官网下载安装包即可一键安装，安装包括两部分，一部分是安装Node.js，另一部分是安装npm，npm全称Node Package Manager，就是Node包的一个管理工具，是Node.js下主流的套件管理器，类似于Ubuntu的apt，python的pip等\n\n![](/img/hexo/01.png)\n(Node.js安装截图)\n\n　安装完后，用命令行检查有没有安装成功\n\n``` bash\nnode -v\nnpm -v\n```\n\n### 安装Hexo\n　Hexo是一款基于Node.js的静态博客框架，用命令可以快速安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n\n　如果执行上面命令遇到报错Error: EACCES: permission denied，加上sudo重新运行就行了\n\n``` bash\nsudo npm install -g hexo-cli\n```\n\n### 初始化Hexo\n　依次执行以下命令就可以完成Hexo的初始化，非常简单，其中blog表示博客项目存放的根目录，可以替换自己喜欢的名字\n\n``` bash\nhexo init blog\ncd blog\nnpm install\n```\n\n　node项目目录下带有package.json，\"dependencies\"字段标识了项目所使用的依赖模块，`npm install`命令会检查并自动下载依赖模块\n\n![](/img/hexo/02.png)\n\n　Hexo初始化完成后，指定文件夹目录下有：\n- node_modules: 依赖包\n- public：存放生成的页面\n- scaffolds：生成文章的一些模板\n- source：用来存放你的文章\n- themes：主题\n- _config.yml: 博客的配置文件\n\n### 运行Hexo\n\n``` bash\nhexo server\n```\n\n　运行完命令后，浏览器打开`http://localhost:4000`，看到《Hello World》，Hexo就已经在本地成功跑起来了，大功告成~\n\n![](/img/hexo/03.png)\n\n### 部署Hexo\n\n　每次写了新的博客或者更改了主题样式，都需要重新部署hexo，按照下面三个步骤依次进行：\n\n``` bash\nhexo clean\nhexo generate\nhexo deploy\n```\n\n　hexo clean清除了你之前生成的东西\n\n　运行`hexo generate`命令，Hexo引擎将markdown格式的文件解析成可以使用浏览器查看的HTML文件，HTML文件存储在blog/public目录下\n\n### 配置Hexo主题\n\n　Hexo博客主题都存放在blog/themes文件夹下，Hexo提供了默认主题landscape，如果想要替换自己的主题，可以把主题放在blog/themes文件夹下，然后修改config.yml文件的theme字段\n\n![](/img/hexo/04.png)\n\n## GitHub Page托管博客\n~\n\n(Updating...)\n\n","tags":["程序猿的自我修养"]}]