[{"title":"从函数指针到回调函数","url":"/2018/04/09/从函数指针到回调函数/","content":"\n\n　C++(包括C语言)中最灵活的技术就是指针，在操作一个对象或者数组时，我们常常用到指针，可以给编程带来很多灵活性，而指针不仅仅能指向对象或者固定数据类型，还可以指向函数，这就是函数指针\n\n　有了函数指针，我们可以通过指针调用函数，更重要的是我们可以将函数指针作为参数传递给函数，进而可以实现回调函数(callback)功能，所以有了函数指针，我们的程序可以设计的更加灵活，这也正是C++的魅力(当然指针是一把双刃剑，使用不当也会引发灾难:)\n\n## 函数指针\n\n### 函数指针的简单定义\n\n　C++中函数声明由3部分组成，分别是函数的参数、返回类型和函数名，其中参数和返回类型这两项决定了函数类型，函数类型与函数名无关，以下例子中函数类型为int(int)\n\n```\n// 函数声明\nint PrintInt(int i);\n\n// 函数定义\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n```\n\n　声明一个指向某种函数类型的函数指针非常简单，只需要用指针替换函数名即可，以下例子中声明了一个函数指针，可以指向函数类型为int(int)的函数，这里要注意，函数指针 `(*pFunc)` 两边的括号必不可少，否则声明的就不再是函数指针，而是返回值为(int *)型指针的函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 注意: pFunc不是函数指针，而是返回值为(int *)的函数\nint *pFunc(int i);\n```\n\n　声明函数指针完成后，函数指针处于未初始化的状态，需要将函数地址赋值给函数指针，然后就可以通过函数指针来调用函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 将函数地址赋值给函数指针\n　pFunc = PrintInt;   // pFunc = &PrintInt; 也可以\n　\n　// 通过函数指针来调用函数\n　pFunc(1);   // (*pFunc)(1); 也可以\n　\n　return 0;\n}\n```\n\n　其实在声明和定义函数的时候，函数名就是一个函数指针，只不过是一个常量函数指针，而在声明函数指针的时候，声明的是一个变量函数指针\n\n### 函数指针的typedef定义\n\n　声明函数指针的格式为 `返回值 (*函数指针名)(参数列表)`，每次需要声明一个函数指针的时候，都需要这样声明一长串显然很麻烦，可以用typedef关键字，定义某一种类型的函数指针，给它一个别名，然后用别名去声明函数指针就会像声明一个int型变量一样方便\n\n```\n// 使用typedef时，PTRFUNC不再是具体指针\n// PTRFUNC表示指向某种函数类型的函数指针类型 (拗口)\ntypedef int (*PTRFUNC)(int i);\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 通过PTRFUNC声明指针，并赋值\n　PTRFUNC pFunc = PrintInt;\n　\n　// 通过函数指针来调用函数\n　pFunc(1);\n　\n　return 0;\n}\n```\n\n### 函数指针作为函数的参数\n\n　有了函数指针，我们就可以像传递普通指针那样将一个函数作为参数传递给另一个函数，这大大的增加了我们编程的灵活性\n\n```\n// 定义int(int,int)类型的函数指针\ntypedef int (*CALLFUNC)(int,int);\n\n// CALLFUNC类型的函数作为参数\nvoid HandleFunc(CALLFUNC pFunc,int x,int y)\n{\n　cout << pFunc(x, y) << endl;\n}\n\n// 加法函数\nint AddFunc(int x,int y)\n{\n　return (x + y);\n}\n\n// 减法函数\nint SubFunc(int x,int y)\n{\n　return (x - y);\n}\n\nint main()\n{\n　// 将函数指针作为参数传递给函数\n　// &符号可以省略\n　HandleFunc(&AddFunc, 2, 1);\n　HandleFunc(&SubFunc, 2, 1);\n　\n　return 0;\n}\n```\n\n## 回调函数\n\n　掌握了函数指针，以及将函数指针作为参数进行传递的方法，我们就能实现函数指针最有用的功能 —— 回调函数(callback)\n\n　对于很多C++初学者来说，往往会觉得回调函数很神秘，其实要完全搞清楚回调函数只需要明白两个问题：\n\n> - 什么是回调函数？\n> \n> - 为什么要使用回调函数？\n\n### 什么是回调函数？\n\n　网上对于回调函数的定义五花八门，简而言之，回调函数就是一个通过函数指针调用的函数，如果你把函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数\n\n### 为什么要使用回调函数？\n\n　同样用一句话概括使用回调函数的最大作用，就是实现通知机制 (除此之外，回调函数还可以调用者和被调用者解耦)\n\n　关于调用普通函数和回调函数，我们用订蛋糕做个比喻，调用普通函数就好像你直接去蛋糕店订一个蛋糕，订完之后，你并不知道蛋糕什么时候会做好，所以你就需要一直在蛋糕店等着，一直到蛋糕做好了，才能取蛋糕；而回调函数就好像你去蛋糕店订一个蛋糕，这时蛋糕店会留下你的联系方式，当蛋糕做好了，蛋糕店就会给你打电话，让你去取蛋糕\n\n```\n### 调用普通函数 ###\n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　bool MakeCake();   // 做蛋糕函数，如果做好了返回true，否则返回false　\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n};\n\nBaker::Baker():m_iTime(0){}\n\nbool Baker::MakeCake()\n{\n　// 每次调用该函数，m_iTime+1\n　m_iTime += 1;\n　\n　if (m_iTime == m_iMaxTime)\n　{\n　　cout << \"蛋糕做好了!\" << endl;\n　　return true;\n　}\n　\n　return false;\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\t\n　// 做蛋糕\n　while(1)\n　{\n　　// 客户如果想第一时间知道蛋糕做没做好，就必须每时每刻查看蛋糕的情况\n　　if( baker.MakeCake() )\n　　{\n　　　GetMyCake();\n　　　break;\n　　}\n　　else\n　　{\n　　　cout << \"蛋糕没做好\" << endl;\n　　}\n　}\n\n　return 0;\n}\n```\n\n　我们如果想要第一时间知道蛋糕有没有做好，就必须一直查询蛋糕有没有做好，换句话说，我们不能去干别的事情，如果这是一个线程的话，那么这个线程在这段时间就不能做其他事情，至少不能100%专注做别的事情，因为必须保持关注蛋糕有没有做好，这显然很低效，而使用回调函数，就可以实现通知机制，大大提升效率\n\n```\n### 回调函数 ###\n\n// 声明回调函数\ntypedef void (*CALLBACKFUNC)(void);  \n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　void MakeCake();   // 做蛋糕函数\n　void Invoke(CALLBACKFUNC);   // 注册回调函数：留下订蛋糕的人的联系方式\n　void Notify();   // 通知订蛋糕的人\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n　CALLBACKFUNC m_pfCallBack;   // 回调函数\n};\n\nBaker::Baker():m_iTime(0){}\n\nvoid Baker::MakeCake()\n{\n　while(m_iTime < m_iMaxTime)\n　{\n　　// 每次调用该函数，m_iTime+1\n　　m_iTime += 1;\n　}\n　\n　cout << \"蛋糕做好了!\" << endl;\n　\n　Notify();\n}\n\nvoid Baker::Invoke(CALLBACKFUNC pFunc)\n{\n　m_pfCallBack = pFunc;\n　cout << \"留下了你的联系方式!\" << endl;\n}\n\nvoid Baker::Notify()\n{\n　if(m_pfCallBack)\n　　m_pfCallBack();\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\n　// 注册：留下联系方式\n　baker.Invoke(GetMyCake);\n　\n　// 注册之后，客户就不需要实时查询了\n　cout << \"好了请通知我!\" << endl;\n　\n　// 做蛋糕\n　baker.MakeCake();\n　\n　return 0;\n}\n```\n\n　在类中使用回调函数，先要注册回调函数，然后在某项任务完成以后，调用回调函数实现通知机制，比如我们做异步加载时，如果我们需要某个资源，就可以去加载线程注册一下，然后主线程继续做其他工作，加载线程加载完需要的资源之后，通过回调函数通知主线程，这样加载和主要功能就可以同时进行，大大的提升了用户体验\n\n\n","tags":["C++"]},{"title":"Hexo+GitHub搭建属于自己的Blog","url":"/2018/04/08/Hexo+GitHub搭建属于自己的Blog/","content":"\n　现在市面上可供程序猿们选择的博客已经有很多，如常见的CSDN，博客园和简书等等，然而这些平台有着各种各样的限制，各种不自由，加上烦人的小广告，让你的Blog看起来一点也不geek，一点都没“范儿”\n\n　有一些程序猿，包括我自己也尝试过搭建LNMP环境，用WordPress建站，但是这种方案的成本实在太高了，不光是服务器的购买成本，单单是去维护网站运行就需要花费不少精力，特别是对于LNMP架构不熟悉的人来说，Debug也常常很让人头疼\n\n　于是Hexo+GitHub成为了我选择的一种折中方案（也可以选择jekyll+GitHub的方案，实现类似），用Hexo作为一个快速简洁的博客框架，在GitHub Page平台上托管博客，可以非常方便省心的搭建起属于我们自己的博客\n\n## Hexo搭建\n　Hexo是一个基于Node.js的静态博客框架，安装依赖少，可以方便的生成静态网页，下面介绍macOS环境搭建Hexo的步骤:\n\n### 安装Node.js\n　Node是一个让JavaScript运行在服务端的开发平台，JavaScript是一门流行的前端语言，但是在2009年，国外开发者Ryan推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js，第一次把JavaScript带入到后端服务器开发，让Node一下子就火了起来\n\n　直接从Node.js官网下载安装包即可一键安装，安装包括两部分，一部分是安装Node.js，另一部分是安装npm，npm全称Node Package Manager，就是Node包的一个管理工具，是Node.js下主流的套件管理器，类似于Ubuntu的apt，python的pip等\n\n![](/img/hexo/01.png)\n(Node.js安装截图)\n\n　安装完后，用命令行检查有没有安装成功\n\n``` bash\nnode -v\nnpm -v\n```\n\n### 安装Hexo\n　Hexo是一款基于Node.js的静态博客框架，用命令可以快速安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n\n　如果执行上面命令遇到报错Error: EACCES: permission denied，加上sudo重新运行就行了\n\n``` bash\nsudo npm install -g hexo-cli\n```\n\n### 初始化Hexo\n　依次执行以下命令就可以完成Hexo的初始化，非常简单，其中blog表示博客项目存放的根目录，可以替换自己喜欢的名字\n\n``` bash\nhexo init blog\ncd blog\nnpm install\n```\n\n　node项目目录下带有package.json，\"dependencies\"字段标识了项目所使用的依赖模块，`npm install`命令会检查并自动下载依赖模块\n\n![](/img/hexo/02.png)\n\n　Hexo初始化完成后，指定文件夹目录下有：\n- node_modules: 依赖包\n- public：存放生成的页面\n- scaffolds：生成文章的一些模板\n- source：用来存放你的文章\n- themes：主题\n- _config.yml: 博客的配置文件\n\n### 运行Hexo\n\n``` bash\nhexo server\n```\n\n　运行完命令后，浏览器打开`http://localhost:4000`，看到《Hello World》，Hexo就已经在本地成功跑起来了，大功告成~\n\n![](/img/hexo/03.png)\n\n### 部署Hexo\n\n　每次写了新的博客或者更改了主题样式，都需要重新部署hexo，按照下面三个步骤依次进行：\n\n``` bash\nhexo clean\nhexo generate\nhexo deploy\n```\n\n　hexo clean清除了你之前生成的东西\n\n　运行`hexo generate`命令，Hexo引擎将markdown格式的文件解析成可以使用浏览器查看的HTML文件，HTML文件存储在blog/public目录下\n\n### 配置Hexo主题\n\n　Hexo博客主题都存放在blog/themes文件夹下，Hexo提供了默认主题landscape，如果想要替换自己的主题，可以把主题放在blog/themes文件夹下，然后修改config.yml文件的theme字段\n\n![](/img/hexo/04.png)\n\n## GitHub Page托管博客\n~\n\n(Updating...)\n\n","tags":["程序猿的自我修养"]}]