---
layout: post
title: 观察者(Observer)模式
date: 2018-03-07
tags: 设计模式
---

　软件架构中不同的模块(或者类)之间的关联关系分为 `紧耦合` 和 `松耦合` 两种，紧耦合系统中更新一个模块会导致其它关联耦合模块的变化，在一些要求模块间更加独立的系统中，松耦合显然更为合适，松耦合系统通常是基于消息的系统，观察者模式就是实现松耦合系统的常用方式

　观察者模式可以说是应用最多、影响最广的模式之一，观察者模式建立一对多(Subject-Observer)的依赖关系，并且做到当“一”(Subject)变化的时候，这个“一”的“多”(Observer)也都将被通知

　软件开发中经典的MVC(Model-View-Controller)框架是观察者模式最好的一个实例，使用MVC框架的目的是将Model和View的实现分离，如果View改变，则通过Controller去同步改变Model，而如果Model改变，则通过观察者模式去通知View更新

### 观察者模式的定义

　观察者模式定义对象间的一对多的关系，当一个对象的状态发生改变时，所有关注他的对象都会被通知并被自动更新，这种交互也称为发布-订阅(publish-subscribe)，这个“一”(Subject)称为发布者，这个“一”的“多”(Observer)称为观察者，发布者发出通知时，并不需要知道谁是他的观察者

![](/images/posts/DesignPattern/Observer.jpg)

　UML类图中目标(Subject)对象提供了注册(Attach)和注销(Detach)两个操作接口，对目标感兴趣的对象可以通过这两个操作接口来订阅目标对象，从而成为目标的观察者(Observer)，这样当目标状态改变时，会通过通知(Notify)接口通知所有依赖于他的观察者，所有的观察者接收到通知后，会通过更新(Update)操作接口来做出相应的操作

### 观察者模式的代码实现(C++)

```
// 模拟通知公司内部员工的场景

#include <iostream>
#include <string>
#include <list>

using namespace std;

// 抽象观察者
class Observer;

// 抽象发布者
class Subject
{
public:
　string action;
　virtual void attach(Observer *) = 0;
　virtual void detach(Observer *) = 0;
　virtual void notify() = 0;
protected:
　list<Observer *> observers;
}

class Observer
{
public:
　// 构造函数
　Observer(string name, Subject *subject)
　{
　　this->name = name;
　　this->subject = subject;
　}
　virtual void update() = 0;
protected:
　string name;
　Subject *subject;
}

// 具体发布者 - 秘书
class Secretary : public Subject
{
　void attach(Observer *observer)
　{
　　observers.push_back(observer);
　}

　void detach(Observer *observer)
　{
　　list<Observer *>::iterator iter = observers.begin();
　　while(iter != observers.end())
　　{
　　　if((*iter) == observer)
　　　{
　　　　observers.erase(iter);
　　　}
　　　++iter;
　　}
　}

　void notify()
　{
　　list<Observer *>::iterator iter = observers.begin();
　　while(iter != observers.end())
　　{
　　　(*iter)->update();
　　　++iter;
　　}
　}
}

// 具体观察者 - 炒股同事
class StockObserver : public Observer
{
public:
　StockObserver(string name, Subject *subject) : Observer(name, subject){}
　void update();
}

void StockObserver::update()
{
　cout << name << " 收到消息：" << subject->action << endl;
　if(subject->action == "经理来了！")
　{
　　cout << "马上关闭股票，装做很认真工作的样子！" << endl;
　}
}

// 具体观察者 - 看球同事
class FIFAObserver : public Observer
{
public:
　FIFAObserver(string name, Subject *subject) : Observer(name, subject){}
　void update();
}

void FIFAObserver::update()
{
　cout << name << " 收到消息：" << subject->action << endl;
　if(subject->action == "经理来了！")
　{
　　cout << "马上关闭FIFA，装做很认真工作的样子！" << endl;
　}
}

int main()
{
　// 创建发布者
　Subject *SS = new Secretary();
　// 创建观察者
　Observer *SO = new StockObserver("stock observer", SS);
　Observer *FO = new FIFAObserver("fifa observer", SS);
　
　// 加入观察者队列
　SS->attach(SO);
　SS->attach(FO);
　
　// 通知事件A
　SS->action = "去吃饭了！";
　SS->notify();
　cout << endl;
　
　// 通知事件B
　SS->action = "经理来了！";
　SS->notify();
　cout << endl;

　return 0;
}

```




