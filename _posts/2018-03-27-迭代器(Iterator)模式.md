---
layout: post
title: 迭代器(Iterator)模式
date: 2018-03-27
tags: 设计模式
---

　当我们外出旅行，住在酒店看电视的时候，我们使用 `前一频道` 和 `后一频道` 按钮可以很方便的换电视台，当按下 `后一频道` 按钮时，将切换到下一个预置的电视台，我们并不知道也不需要去记几号频道对应的是哪个电视台，当切换频道时，我们只关心电视台播放的内容是不是自己喜欢的

　看电视的场景反应的其实迭代器模式的目的，我们会需要一种方法去顺序的访问某个集合中的每个元素，只需要关心元素的具体内容，并不需要关心其他细节，C++ STL中访问各种容器的iterators，就是一个迭代器的实例

### 迭代器模式的定义

　迭代器模式提供一种方法访问一个容器对象中的各个元素，而不暴露该对象的内部细节，迭代器是为容器对象服务的，迭代器提供了遍历容器的方法，容器只需要管理增减元素，遍历的工作就交给迭代器完成

![](/images/posts/DesignPattern/Iterator.jpg)

　UML类图中抽象迭代器(Iterator)除了提供next()接口，经常也会提供first()、currentItem()、isDone()等接口

### 迭代器模式的代码实现(C++)

```
#include <iostream>
#include <vector>

using namespace std;

template<class Item>
class Iterator
{
public:
　virtual void first()=0;
　virtual void next()=0;
　virtual Item* currentItem()=0;
　virtual bool isDone()=0;
　virtual ~Iterator(){}
};

template<class Item>
class ConcreteAggregate;

template<class Item>
class ConcreteIterator : public Iterator<Item>
{
public:
　ConcreteIterator(ConcreteAggregate<Item> *a):aggr(a),cur(0){}
　
　virtual void first()
　{
　　cur=0;
　}
　
　virtual void next()
　{
　　if(cur < aggr->getLen())
　　cur++;
　}
　
　virtual Item* currentItem()
　{
　　if(cur < aggr->getLen())
　　　return &(*aggr)[cur];
　　else
　　　return NULL;
　}

　virtual bool isDone()
　{
　　return (cur >= aggr->getLen());
　}

private:
　ConcreteAggregate<Item> *aggr;
　int cur;
};

template<class Item>
class Aggregate
{
public:
　virtual Iterator<Item>* createIterator()=0;
　virtual ~Aggregate(){}
};

template<class Item>
class ConcreteAggregate : public Aggregate<Item>
{
public:
　ConcreteAggregate()
　{
　　data.push_back(1);
　　data.push_back(2);
　　data.push_back(3);
　}

　virtual Iterator<Item>* createIterator()
　{
　　return new ConcreteIterator<Item>(this);
　}

　Item& operator[](int index)
　{
　　return data[index];
　}

　int getLen()
　{
　　return data.size();
　}

private:
　vector<Item> data;
};

int main()
{
　Aggregate<int> *aggr = new ConcreteAggregate<int>();
　Iterator<int> *it = aggr->createIterator();

　for(it->first(); !it->isDone(); it->next())
　{
　　cout << *(it->currentItem()) << endl;
　}
　
　delete it;
　delete aggr;
　
　return 0;
}

```




