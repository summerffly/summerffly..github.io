---
layout: post
title: Windows控件通知消息
date: 2018-03-03
tags: Windows消息机制
---

　Windows消息数量庞大，记得自己刚工作接触Windows消息的时候，面对着错综复杂的Windows消息，经常晕头转向找不着北，其实真的把Windows消息全面梳理清楚，并不难掌握，对于初学者来说用的最多的也最重要的，就是控件通知消息

　控件通知消息可以被映射为WM_COMMAND和WM_NOTIFY两种消息

### WM_COMMAND消息

　WM_COMMAND消息其实是早期WIN3.X时代的子窗体消息，子窗体给父窗体发送消息，父窗体就捕获WM_COMMAND来处理子窗体的消息

　首先看 MSDN 对WM_COMMAND消息的解释：

```
/*
wParam :
The low-order word of wParam identifies the command ID of the menu item, control, or accelerator. 
The high-order word of wParam specifies the notification message if the message is from a control. 
If the message is from an accelerator, the high-order word is 1. If the message is from a menu, the high-order word is 0.
lParam :
Identifies the control that sends the message if the message is from a control. Otherwise, lParam is 0. 
*/
```

　WM_COMMAND消息只包含了非常有限的信息，两个参数wParam包括了子窗口ID和通知消息，lParam则包括了子窗口句柄。如果子窗体需要向父窗体发送其他信息，就必须借助其他WM_**消息来传递，所以Windows 3.1中定义了许多其它的消息，比如WM_VSCROLL，WM_CTLCOLOR等等，每种消息中的wParam，lParam附带的信息是不同的

　当用户点击菜单、控件或者加速器的时候，会触发WM_COMMAND消息，LOWORD(wParam) 是菜单、控件或者加速器的ID，HIWORD(wParam) 是通知消息(notification message)：

- 如果LOWORD(wParam) 是菜单ID，HIWORD(wParam) 是0，lParam为NULL
- 如果LOWORD(wParam) 是加速符ID，HIWORD(wParam) 是1，lParam为NULL
- 如果LOWORD(wParam) 是控件ID，HIWORD(wParam) 是通知消息，lParam是控件的句柄值

　列出常用的通知消息：

- 按扭控件
  - BN_CLICKED  # 单击按钮
  - BN_DOUBLECLICKED  # 双击按钮
  - BN_DISABLE  # 禁止按钮
  - BN_HILITE  # 加亮按钮
  - BN_UNHILITE  # 取消加亮按钮
  - BN_PAINT  # 重画按钮

- 编辑框控件
  - EN_UPDATE  # 编辑框中的文本将要更新
  - EN_CHANGE  # 编辑框中的文本己更新
  - EN_ERRSPACE  # 编辑框内存不足
  - EN_SETFOCUS  # 编辑框获得输入焦点
  - EN_KILLFOCUS  # 编辑框正在失去输入焦点
  - EN_HSCROLL  # 点击水平滚动条
  - EN_VSCROLL  # 点击垂直滚动条

- 列表框控件
  - LBN_DBLCLK  # 用户双击了一项
  - LBN_ERRSPACE  # 列表框内存不够
  - LBN_KILLFOCUS  # 列表框正在失去输入焦点
  - LBN_SELCANCEL  # 选择被取消
  - LBN_SELCHANGE  # 选择了另一项
  - LBN_SETFOCUS  # 列表框获得输入焦点

### WM_NOTIFY消息

　随着Windows的发展，控件的种类和用法都越来越丰富，WM_COMMAND消息已经不能满足通知需求，当然也不可能为每一个控件都定义一套消息，这样会让系统非常混乱，不利于程序开发，于是Microsoft在Win32中引进NMHDR (Notification Message Handler)结构，增加了强大的WM_NOTIFY消息

　WM_NOTIFY消息遵守原来的消息规则，包含wParam和lParam两个参数，wParam包含了控件ID，lParam则包含了一个结构体的指针，这个结构体是NMHDR结构或者以NMHDR结构为第一项的一个更大的结构体，这样就可以包含很多子控件给父窗体提供的信息

```
typedef struct tagNMHDR{
　HWND hWndFrom;  // handle of control sending message
　UINT idFrom;  // identifier of control sending message
　UINT code;  // notification code
} NMHDR;
```

　对比发现 NMHDR 结构中hWndFrom相当于原WM_COMMAND消息传递方式的lParam，idFrom相当于原WM_COMMAND消息传递方式的wParam(low-order)，code相当于原WM_COMMAND消息传递方式的wParam(high-order)

　WM_NOTIFY消息按照lParam中的指针，可以分为两类：

> - 控件不带附加信息 -> 结构变得很简单，就是一个NMHDR结构
> 
> - 控件带有附加信息 -> 定义一个大的结构，它的第一个元素就是NMHDR结构，它的后面放置附加信息

　以树形控件的通知消息举例，当用户改变了对树节点的选择时，树形控件会发出通知码为TVN_SELCHANGED的WM_NOTIFY消息，该消息的lParam指向NMTREEVIEW结构的指针，NMTREEVIEW结构的第一项就是一个标准的NMHDR结构，程序可从该结构中获得必要的信息

```
typedef struct tagNMTREEVIEW {   
    NMHDR hdr;   // 标准的NMHDR结构   
    UINT action;   // 表明是用户的什么行为触发了该通知消息   
    TVITEM itemOld;  // 原节点的属性   
    TVITEM itemNew;  // 新节点的属性   
    POINT ptDrag;   // 事件发生时鼠标的客户区坐标   
} NMTREEVIEW, *LPNMTREEVIEW;  
```

## 响应控件通知消息的函数和宏

### 重写OnCommand()函数

　OnCommand()成员函数是专门响应WM_COMMAND消息的，可以重写在派生类中OnCommand()成员函数，按自己的方式来处理WM_COMMAND消息，需要在OnCommand()中自己解wParam和lParam

```
// 声明
virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// 定义
BOOL CDlgTest::OnCommand(WPARAM wParam, LPARAM lParam)
{
　switch(LOWORD(wParam))
　{
　　case IDC_BTN_BEGIN:  
　　{
　　　if(HIWORD(wParam) == WM_RBUTTONDOWN)
　　　　AfxMessageBox(_T("开始"));
　　　break;  
　　}
　　case IDC_BTN_END:  
　　{
　　　if(HIWORD(wParam) == WM_LBUTTONDBLCLK)
　　　　AfxMessageBox(_T("结束"));
　　　break;  
　　}
　}
　return CDialog::OnCommand(wParam, lParam);
}
```

### ON_COMMAND(NotifyCode, memberFxn)宏

　ON_COMMAND宏是专门处理WM_COMMAND消息的，这样就不用自己解开WM_COMMAND消息中wParam和lParam中传送的控件ID，事件种类...（所有的都在MFC内部解决了），当接受到WM_COMMAND消息时，ON_COMMAND宏将调用成员函数memberFxn处理此消息

```
BEGIN_MESSAGE_MAP()
　ON_COMMAND(ID_APP_ABOUT, memberFxnA)
　ON_COMMAND(CTimeSlider::IDC_MENU_**, memberFxnB)
END_MESSAGE_MAP()
```

### ON_CONTROL(NotifyCode, ControlID, memberFxn)宏

　ON_CONTROL宏和如ON_BN_CLICKED、ON_LBN_DBLCLK等宏，也是响应WM_COMMAND消息的，可以专门用来处理如BN_CLICKED、LBN_DBLCLK等特定的通知消息，需要指定控件ID和处理该消息的成员函数memberFxn

```
BEGIN_MESSAGE_MAP()
　ON_CONTROL(BN_CLICKED, IDC_BTN_**, memberFxnA)
　ON_BN_CLICKED(IDC_BTN_**, memberFxnB)
END_MESSAGE_MAP()
```

### ON_NOTIFY(NotifyCode, ControlID, memberFxn)宏

　ON_NOTIFY宏的作用和ON_CONTROL宏很类似，区别在于ON_NOTIFY宏响应WM_NOTIFY消息，而不是WM_COMMAND消息

```
BEGIN_MESSAGE_MAP()
　ON_CONTROL(TVN_SELCHANGED, IDC_TREE_**, memberFxn)
END_MESSAGE_MAP()
```


