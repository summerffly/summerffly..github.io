---
layout: post
title: 工厂(Factory)模式
date: 2018-04-15
tags: 设计模式
---

　工厂模式是让新手程序员很费解的模式，很多人会疑惑工厂仅仅是封装了new显得多此一举，其实在实际的项目中，特别是往架构师方向发展的程序员要培养出一种感觉：要new一个实体对象是件很谨慎的事情，最好让别人new完再调用

　工厂模式也分为简单工厂模式和抽象工厂模式，真正算得上设计模式的，是抽象工厂模式，很多教材都会着重介绍抽象工厂模式，反而忽略了简单工厂模式，实际项目中却刚好相反，简单工厂模式几乎是每个程序员都会遇到，而抽象工厂模式很多人整个职业生涯也用不到几次，本篇先介绍简单工厂模式

### 简单工厂模式的定义

　简单工厂模式属于创建型模式，又叫做静态工厂方法(Static Factory Method)模式，简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一类产品类

### 简单工厂模式的代码实现(C++)

```
#include <iostream>

using namespace std;

class Product
{
public:
　virtual void show() = 0;  
};

class Product_A : public Product
{
public:
　void show()
　{
　　cout << "Product_A" << endl;
　}
};

class Product_B : public Product
{
public:
　void show()
　{
　　cout << "Product_B" << endl;
　}
};

class Factory
{
public:
　Product* Create(int i)
　{
　　switch (i)
　　{
　　　case 1:
　　　　return new Product_A;
　　　　break;
　　　case 2:
　　　　return new Product_B;
　　　　break;
　　　default:
　　　　break;
　　}
　}
};

int main()
{
　Factory *factory = new Factory();
　
　factory->Create(1)->show();
　factory->Create(2)->show();

　return 0;
}
```

### 工厂方法模式的定义

　简单工厂模式有一个难以克服的缺点，当新增产品的时候就要去修改工厂的类，这就违反了开放封闭原则，为了规避这一缺点，就出现了工厂方法模式，工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类

![](/images/posts/DesignPattern/Factory-Method.jpg)

### 工厂方法模式的代码实现(C++)

```
#include<iostream>

using namespace std;

class Product
{
public:
　virtual void show() = 0;  
};

class Product_A : public Product
{
public:
　void show()
　{
　　cout << "Product_A" << endl;
　}
};

class Product_B : public Product
{
public:
　void show()
　{
　　cout << "Product_B" << endl;
　}
};

class Factory
{
public:
　virtual Product* create() = 0;
};

class Factory_A : public Factory
{
public:
　Product* create()
　{
　　return new Product_A;
　}
};

class Factory_B : public Factory
{
public:
　Product* create()
　{
　　return new Product_B;
　}
};

int main()
{
　Factory_A *factoryA = new Factory_A();
　Factory_B *factoryB = new Factory_B();

　factoryA->create()->show();
　factoryB->create()->show();
　
　return 0;
}
```


