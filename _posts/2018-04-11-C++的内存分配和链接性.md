---
layout: post
title: C++的内存分配和链接性
date: 2018-04-11
tags: 程序猿的自我修养 C++
---

　C++程序（包括其他语言的程序）由代码和数据两部分组成，代码存储在代码区中，数据根据类型的不同存储在不同的内存区域中，下面介绍内存区域的划分

### C++的内存分配

- **栈(stack)：**

	由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区，栈通常存储局部变量、函数参数等，在一个进程中，位于用户虚拟地址空间顶部的是栈，栈的地址向下生长

- **堆(heap)：**

	由new分配的内存块存储区，堆中内存块的释放编译器不会检查，需要在代码中自己控制，一般一个new就需要对应一个delete，如果没有delete，会造成内存泄漏，在应用程序结束后，会自动回收

- **自由存储区：**

	由malloc分配的内存块存储区，由free来回收，和堆的作用很类似

- **全局/静态存储区：**

	全局变量和静态变量的存储区，在C语言中，全局变量和静态变量分为初始化的和未初始化的，未初始化的全局变量和静态变量会被用0来填充，存储在全局/静态存储区中的BSS(Block Started by Symbol)数据段，已经初始化的变量放在相邻的另一个数据段，在C++中已经没有这个区分，初始化的和未初始化的变量都共享同一块内存区

- **常量存储区：**

	专门用来存放常量的存储区

下面的代码显示了不同类型变量的存储方式：

```
#include <iostream>
using namespace std;

const int aa = 1;   // 常量存储区

int bb = 2;   // 全局/静态存储区
static int cc = 3;   // 全局/静态存储区

int dd;   // 全局/静态存储区
static int ee;   // 全局/静态存储区

int main()
{
　int a;   // 栈(stack)
　int b;   // 栈(stack)

　static int c = 0;   // 全局/静态存储区
　static int d;   // 全局/静态存储区

　int *p = new int[5];   // 堆(heap)
　delete []p;   // 一定要释放，否则会造成内存泄漏
    
　return 0;
}
```

### 堆和栈的区别

- **管理方式：**

	栈由编译器自动管理，无需手动控制；堆由new/delete来控制，申请后没有释放内存容易造成memory leak；

- **空间大小：**

	一般在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的；对于栈来讲，一般都是有一定的空间大小的，例如在VC6下面，默认的栈空间大小是1M，也可以在工程中修改栈的大小；

- **碎片问题：**

	频繁的new/delete势必会造成堆内存空间的不连续，从而造成大量的碎片；而栈则不存在这个问题；

- **生长方向：**

	栈的生长方向是向下的，是向着内存地址减小的方向增长；堆的生长方向是向上的，也就是向着内存地址增加的方向；

- **分配方式：**

	堆都是动态分配的，没有静态分配的堆；栈有静态分配和动态分配2种分配方式，都由编译器实现；

- **分配效率：**

	计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，栈的分配效率比较高；而堆的分配效率比较低；

### C++的链接性

　C++栈中存储的自动变量一定是无链接性的，而全局/静态存储区存储的静态变量按照链接性可以分为三种，分别是：外部链接性,内部链接性和无链接性

- **外部链接性：**

	外部链接性的静态变量在代码块之外声明，不带static，具有多文件作用域；

- **内部链接性：**

	内部链接性的静态变量同样在代码块之外声明，带static，作用域仅限于单文件；

- **无链接性：**

	无链接性的静态变量在代码块中声明，带static，作用域仅限于声明的代码块中

下面的代码显示了不同变量的链接性：

```
#include <iostream>
using namespace std;

int x = 1;   // 声明外部链接性的变量
static int y;    // 声明内部链接性的变量

int func()
{
　static int z;   // 声明无链接的变量
}

int main()
{
　return 0;
}
```

