---
layout: post
title: 策略(Strategy)模式
date: 2018-03-30
tags: 设计模式
---

　我们每个人都要交个人所得税，把我们的薪资收入作为参数，上报给个人所得税系统，就能算出我们要交的个人所得税是多少，然而 `在美国交个人所得税` 和 `在中国交个人所得税` 这两种情况下，当薪资收入相同时，需要交的个人所得税并不相同，因为两个国家采用的个人所得税计算方法并不相同，这种情况就需要用到策略模式

### 策略模式的定义

　策略模式就是对算法进行包装，是把使用算法的使用场景和算法本身的逻辑分割开来，委派给不同的对象管理，策略模式通常把一系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类，用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”

![](/images/posts/DesignPattern/Strategy.jpg)

### 策略模式的代码实现(C++)

```
// 以吃鸡游戏为例说明策略模式

#include <iostream>

using namespace std;

// 抽象策略类
class WeaponBehavior
{
public:
　virtual void UseWeapon() = 0;
}

// 具体策略类 (AK47)
class Rifle_AK47 : public WeaponBehavior
{
public:
　void UseWeapon()
　{
　　cout << "Use Rifle AK47 to shoot!" << endl;
　}
}

// 具体策略类 (M4)
class Rifle_M4 : public WeaponBehavior
{
public:
　void UseWeapon()
　{
　　cout << "Use Rifle M4 to shoot!" << endl;
　}
}

// 
class Fighter
{
public:
　Character()
　{
　　weapon = 0;
　}
　void setWeapon(WeaponBehavior *w)
　{
　　this->weapon = w;
　}
　void virtual fight() = 0;
private:
　WeaponBehavior *weapon;
};

//
class ConcreteFighter : public Fighter
{
public:
　void fight()
　{
　　if( this->weapon == NULL )
　　{
　　　cout << "You don't have a weapon! Please Set Weapon!" << endl;
　　}
　　else
　　{
　　　weapon->useWeapon();
　　}
　}
};

int main()
{
　WeaponBehavior *ak47 = new Rifle_AK47();
　WeaponBehavior *m4 = new Rifle_M4();
　
　Fighter *player = new ConcreteFighter();
　
　player->fight();
　cout << endl;
　
　player->setWeapon(ak47);
　player->fight();
　cout << endl;
　
　player->setWeapon(m4);
　player->fight();
　
　return 0;
}

```




