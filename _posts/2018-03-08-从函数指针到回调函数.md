---
layout: post
title: 从函数指针到回调函数
date: 2018-03-08
tags: C++
---

　C++(包括C语言)中最灵活的技术就是指针，在操作一个对象或者数组时，我们常常用到指针，可以给编程带来很多灵活性，而指针不仅仅能指向对象或者固定数据类型，还可以指向函数，这就是函数指针

　有了函数指针，我们可以通过指针调用函数，更重要的是我们可以将函数指针作为参数传递给函数，进而可以实现回调函数(callback)功能，所以有了函数指针，我们的程序可以设计的更加灵活，这也正是C++的魅力(当然指针使用不当也会引起灾难，这是一把双刃剑)

## 函数指针

### 函数指针的简单定义

　C++中函数声明由3部分组成，分别是函数的参数、返回类型和函数名，其中参数和返回类型这两项决定了函数类型，函数类型与函数名无关，以下例子中函数类型为int(int)

```
// 函数声明
int PrintInt(int i);

// 函数定义
int PrintInt(int i)
{
　cout << i << endl;
　return i;
}
```

　声明一个指向某种函数类型的函数指针非常简单，只需要用指针替换函数名即可，以下例子中声明了一个函数指针，可以指向函数类型为int(int)的函数，这里要注意，函数指针 `(*pFunc)` 两边的括号必不可少，否则声明的就不再是函数指针，而是返回值为(int *)型指针的函数

```
// 声明函数指针
int (*pFunc)(int i);   // 未初始化

// 注意: pFunc不是函数指针，而是返回值为(int *)的函数
int *pFunc(int i);
```

　声明函数指针完成后，函数指针处于未初始化的状态，需要将函数地址赋值给函数指针，然后就可以通过函数指针来调用函数

```
// 声明函数指针
int (*pFunc)(int i);   // 未初始化

// 声明并定义函数
int PrintInt(int i)
{
　cout << i << endl;
　return i;
}

int main()
{
　// 将函数地址赋值给函数指针
　pFunc = PrintInt;
　// pFunc = &PrintInt也可以
　
　// 通过函数指针来调用函数
　pFunc(1);
　
　return 0;
}
```

### 函数指针的typedef定义

　声明函数指针的格式为 `返回值 (*函数指针名)(参数列表)`，每次需要声明一个函数指针的时候，都需要这样声明一长串显然很麻烦，可以用typedef关键字，定义某一种类型的函数指针，给它一个别名，然后用别名去声明函数指针就会像声明一个int型变量一样方便

```
// 使用typedef时，PTRFUNC不再是具体指针
// PTRFUNC表示指向某种函数类型的函数指针类型 (拗口)
typedef int (*PTRFUNC)(int i);

// 声明并定义函数
int PrintInt(int i)
{
　cout << i << endl;
　return i;
}

int main()
{
　// 通过PTRFUNC声明指针，并赋值
　PTRFUNC pFunc = PrintInt;
　
　// 通过函数指针来调用函数
　pFunc(1);
　
　return 0;
}
```

### 函数指针作为函数的参数

　有了函数指针，我们就可以像传递普通指针那样将一个函数作为参数传递给另一个函数，这大大的增加了我们编程的灵活性

```
// 定义int(int,int)类型的函数指针
typedef int (*CALLFUNC)(int,int);

// CALLFUNC类型的函数作为参数
void HandleFunc(CALLFUNC pFunc,int x,int y)
{
　cout << pFunc(x, y) << endl;
}

// 加法函数
int AddFunc(int x,int y)
{
　return (x + y);
}

// 减法函数
int SubFunc(int x,int y)
{
　return (x - y);
}

int main()
{
　// 将函数指针作为参数传递给函数
　// &符号可以省略
　HandleFunc(&AddFunc, 2, 1);
　HandleFunc(&SubFunc, 2, 1);
　
　return 0;
}
```

## 回调函数

　掌握了函数指针，以及将函数指针作为参数进行传递的方法，我们就能实现函数指针最有用的功能 —— 回调函数(callback)

　对于很多C++初学者来说，往往会觉得回调函数很神秘，其实要完全搞清楚回调函数只需要明白两个问题：

> - 什么是回调函数？
> 
> - 为什么要使用回调函数？

### 什么是回调函数？

　网上对于回调函数的定义五花八门，简而言之，回调函数就是一个通过函数指针调用的函数，如果你把函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数

### 为什么要使用回调函数？

　同样用一句话概括使用回调函数的最大作用，就是实现通知机制 (回调函数还有让调用者和被调用者解耦的作用，可以自行Google)

　关于调用普通函数和回调函数，我们用订蛋糕做个比喻，调用普通函数就好像你直接去蛋糕店订一个蛋糕，订完之后，你并不知道蛋糕什么时候会做好，所以你就需要一直在蛋糕店等着，一直到蛋糕做好了，才能取蛋糕；而回调函数就好像你去蛋糕店订一个蛋糕，这时蛋糕店会留下你的联系方式，当蛋糕做好了，蛋糕店就会给你打电话，让你去取蛋糕
　
```
### 调用普通函数 ###

// 模拟蛋糕店类
class Baker
{
public:
　Baker();   // 构造函数
　bool MakeCake();   // 做蛋糕函数，如果做好了返回true，否则返回false　
private:
　int m_iTime;   // 做蛋糕的时间
　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕
};

Baker::Baker():m_iTime(0){}

bool Baker::MakeCake()
{
　// 每次调用该函数，m_iTime+1
　m_iTime += 1;
　
　if (m_iTime == m_iMaxTime)
　{
　　cout << "蛋糕做好了!" << endl;
　　return true;
　}
　
　return false;
}

// 客户取蛋糕函数
void GetMyCake()
{
　cout << "我来取蛋糕啦!" << endl;
}

int main()
{
　// 创建一个蛋糕店
　Baker baker;
	
　// 做蛋糕
　while(1)
　{
　　// 客户如果想第一时间知道蛋糕做没做好，就必须每时每刻查看蛋糕的情况
　　if( baker.MakeCake() )
　　{
　　　GetMyCake();
　　　break;
　　}
　　else
　　{
　　　cout << "蛋糕没做好" << endl;
　　}
　}

　return 0;
}
```

　我们如果想要第一时间知道蛋糕有没有做好，就必须一直查询蛋糕有没有做好，换句话说，我们不能去干别的事情，如果这是一个线程的话，那么这个线程在这段时间就不能做其他事情，或者至少不能100%专注做别的事情，因为必须保持关注蛋糕有没有做好，这显然很低效，而使用回调函数，就可以实现通知机制，大大提升效率

```
### 回调函数 ###

// 声明回调函数
typedef void (*CALLBACKFUNC)(void);  

// 模拟蛋糕店类
class Baker
{
public:
　Baker();   // 构造函数
　void MakeCake();   // 做蛋糕函数
　void Invoke(CALLBACKFUNC);   // 注册回调函数：留下订蛋糕的人的联系方式
　void Notify();   // 通知订蛋糕的人
private:
　int m_iTime;   // 做蛋糕的时间
　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕
　CALLBACKFUNC m_pfCallBack;   // 回调函数
};

Baker::Baker():m_iTime(0){}

void Baker::MakeCake()
{
　while(m_iTime < m_iMaxTime)
　{
　　// 每次调用该函数，m_iTime+1
　　m_iTime += 1;
　}
　
　cout << "蛋糕做好了!" << endl;
　
　Notify();
}

void Baker::Invoke(CALLBACKFUNC pFunc)
{
　m_pfCallBack = pFunc;
　cout << "留下了你的联系方式!" << endl;
}

void Baker::Notify()
{
　if(m_pfCallBack)
　　m_pfCallBack();
}

// 客户取蛋糕函数
void GetMyCake()
{
　cout << "我来取蛋糕啦!" << endl;
}

int main()
{
　// 创建一个蛋糕店
　Baker baker;

　// 注册：留下联系方式
　baker.Invoke(GetMyCake);
　
　// 注册之后，客户就不需要实时查询了
　cout << "好了请通知我!" << endl;
　
　//做蛋糕
　baker.MakeCake();
　
　return 0;
}
```

　在类中使用回调函数，先要注册回调函数，然后在某项任务完成以后，调用回调函数实现通知机制，比如我们做异步加载时，如果我们需要某个资源，就可以去加载线程注册一下，然后主线程继续做其他工作，加载线程加载完需要的资源之后，通过回调函数通知主线程，这样加载和主要功能就可以同时进行，大大的提升了用户体验


