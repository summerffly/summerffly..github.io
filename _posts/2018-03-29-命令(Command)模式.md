---
layout: post
title: 命令(Command)模式
date: 2018-03-29
tags: 设计模式
---

　当我们去餐厅吃饭，我们通过服务员来点菜，我们只需要关心我们想吃哪些菜，而不需要去关心具体的菜是由谁做的以及这些菜的制作流程，这个场景其实就是一种“命令模式”，我们点的一道道菜就是一个个 `命令(Command)`，帮我们点菜的服务员是命令的 `请求者(Invoker)`，负责做菜的师傅是命令的 `接受者(Reciever)`

### 命令模式的定义

　命令模式将一个请求封装成一个对象，请求者角色与接收者角色之间没有任何依赖关系，实现类间解耦，请求者实现功能时只需调用Command类的execute()方法就可以，不需要知道到底是哪个接收者执行

![](/images/posts/DesignPattern/Command.jpg)

　UML类图中Command的子类ConcreteCommand可以非常容易地扩展，而请求者(Invoker)和高层次的Client模块不产生太多代码耦合

### 命令模式的代码实现(C++)

```
#include <iostream>
#include <vector>

using namespace std;

// 烤肉师傅类
class RoastCook
{
public:
　void RoastSteak();
　void RoastChickenWing();
};

void RoastCook::RoastSteak()
{
　cout << "烤牛排" << endl;
}

void RoastCook::RoastChickenWing()
{
　cout << "烤鸡翅" << endl;
}

// 抽象命令类
class Command
{
public:
　Command(RoastCook *temp) { receiver = temp; }
　virtual void ExecuteCmd() = 0;
protected:
　RoastCook *receiver;
};

// 具体命令类 (烤牛排)
class RoastSteakCmd : public Command
{
public:
　MakeMuttonCmd(RoastCook *temp) : Command(temp) {}
　virtual void ExecuteCmd() 
};

void RoastSteakCmd::ExecuteCmd()
{
　receiver->RoastSteak();
}

// 具体命令类 (烤鸡翅)
class RoastChickenWingCmd : public Command
{
public:
　MakeMuttonCmd(RoastCook *temp) : Command(temp) {}
　virtual void ExecuteCmd() 
};

void RoastSteakCmd::ExecuteCmd()
{
　receiver->ChickenWing();
}

// 服务员类
class Waiter
{
public:
　void AddCmd(Command *temp);
　void Notify();   // 通知执行
private:
　vector<Command*> m_commandList;
};

void Waiter::AddCmd(Command *temp)
{
　m_commandList.push_back(temp);
　cout << "增加烤肉订单" << endl;
}

void Waiter::Notify()
{
　vector<Command*>::iterator it;
　
　for( it = m_commandList.begin(); it != m_commandList.end(); it++ )
　{
　　(*it)->ExecuteCmd();
　}
}

int main()
{
　RoastCook *cook = new RoastCook();
　Command *cmdStk = new RoastSteakCmd(cook);
　Command *cmdChw = new RoastChickenWingCmd(cook);
　Waiter *waiter = new Waiter();
　
　// 增加命令
　waiter->AddCmd(cmdStk);
　waiter->AddCmd(cmdStk);
　
　// 执行命令
　waiter->Notify();
　
　return 0;
}

```




