---
layout: post
title: C++多态的原理和实现
date: 2018-04-09
tags: 程序猿的自我修养 C++
---

　多态（polymorphism）源自希腊语，从字面上理解就是多种形态，多种形式，具体到C++这种面向对象（OOP）的语言中，其实就是“一种接口，多种实现（方法）”，和继承、封装并称为C++语言的三大特性，是C++最重要的核心

### 什么是多态？

　C++中多态并不仅仅是单一的一种技术，而是多种技术的合称，多态可分为**静态多态**和**动态多态**，具体的分类情况如下：

![](/images/posts/C++/Polymorphism.png)

　**静态多态**和**动态多态**的关键区别是函数实现和函数调用关联起来的时间点，是在编译时期还是运行时期，也就是函数地址是**早绑定**还是**晚绑定**

- **静态多态**是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是**早绑定**，静态多态也往往被叫做**静态联编**，通过**泛型编程**和**函数重载**两种方式都可以实现静态多态

```
// 泛型编程(函数模板)
template <typename T>   // typename也可以替换为class
T add(T a, T b)
{
　return a + b;
}
```

```
// 函数重载
int add(int a, int b)
{
　return a + b;
}

double add(double a, double b)
{
　return a + b;
}
```

- **动态多态**则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于**晚绑定**，动态多态也往往被叫做**动态联编**

　静态多态的原理与实现比较容易理解，下面主要讨论动态多态的原理与实现

### 为什么要使用多态？

　C++有封装、继承、多态三大特性，封装可以使得代码模块化，继承可以在原有的代码基础上扩展，继承是为了代码重用，而多态是为了接口重用，不论传递过来的究竟是哪个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法

- 首先看一段代码：

```
class Base
{
public:
　void fun()
　{
　　cout << "Base::fun()" << endl;
　}
};

class Derived : public Base
{
}

int main()
{
　Base b;
　Derived d;
　
　b.fun();   // 调用基类的fun(),打印Base::fun()
　d.fun();   // 子类继承了基类的fun()且子类本身没有fun(),因此此处还是调用基类的fun(),打印Base::fun()
　
　return 0;
}
```

- 在子类中重定义(隐藏)fun()函数，再看这段代码：

```
class Base
{
public:
　void fun()
　{
　　cout << "Base::fun()" << endl;
　}
};

class Derived : public Base
{
public:
　void fun()
　{
　　cout << "Derived::fun()" << endl;
　}
}

int main()
{
　Base b;
　Derived d;
　
　b.fun();   // 调用基类的fun(),打印Base::fun()
　// 子类虽然继承了基类的fun(),但是子类本身中fun()
　// 此时构成了重定义,基类中的fun()被隐藏，调用的是子类的fun()
　// 打印Derived::fun()
　d.fun();
　d.Base::fun();   // 加类的作用域限定符,调用基类的fun(),打印Base::fun()
　
　return 0;
}
```

- 保持上面这段代码的类定义不变，用类指针类调用成员函数，分析执行结果发现，基类指针指向子类，却调用基类自己的fun函数打印Base::fun()，而不是子类的Derived::fun()，这就是因为上面讲的静态联编，其实在编译时期就将函数实现和函数调用关联起来，指针在编译时期是Base类的，自然调用Base类的fun()

```
class Base
{
public:
　void fun()
　{
　　cout << "Base::fun()" << endl;
　}
};

class Derived : public Base
{
public:
　void fun()
　{
　　cout << "Derived::fun()" << endl;
　}
}

int main()
{
　Base b;
　Derived d;
　Base *pb = &b;
　Derived *pd = &d;
　
　pb->fun();   // pb指向基类,打印Base::fun()
　pd->fun();   // pb指向子类,打印Derived::fun()
　
　pb = &d;   // 将基类指针指向子类
　pb->fun();   // pb指向子类,却打印Base::fun()
　
　return 0;
}
```

- 为了避免上一段代码中的这种情况，C++中引入了动态多态，通过**继承**和**虚函数**来实现，在程序运行期间(非编译期)判断所指针指向对象的实际类型，根据其实际类型调用相应的方法，具体格式就是使用**virtual关键字**修饰类的成员函数，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定，以下为用虚函数实现的代码

```
class Base
{
public:
　virtual void fun()
　{
　　cout << "Base::fun()" << endl;
　}
};

class Derived : public Base
{
public:
　void fun()
　{
　　cout << "Derived::fun()" << endl;
　}
}

int main()
{
　Base b;
　Derived d;
　Base *pb = &b;
　Derived *pd = &d;
　
　pb->fun();   // pb指向基类,打印Base::fun()
　pd->fun();   // pb指向子类,打印Derived::fun()
　
　pb = &d;   // 将基类指针指向子类
　pb->fun();   // pb实际指向子类,打印Derived::fun()
　
　return 0;
}
```

　动态多态的实现有两个必要的绑定条件：

- 必须在基类中定义虚函数
- 必须通过基类类型的引用或者指针调用虚函数

### 多态怎么实现？

　C++通过继承和虚函数来实现多态，编译器在编译的时候，会为每个包含虚函数的类创建一个虚表(vtable)，在虚表中存放每个虚函数的地址，编译器另外还为每个对象提供了一个虚表指针(vptr)，这个指针指向了对象所属类的vtable，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的vtable，从而在调用虚函数的时候，能够找到正确的函数

![](/images/posts/C++/vtable.png)

　由于每个对象调用的虚函数都是通过vptr来索引的，因此vptr的正确初始化是非常重要的，在vptr没有正确初始化之前，不能够去调用虚函数，C++在类的构造函数中进行vtable的创建和vptr的初始化，在构造子类对象时，要先调用父类的构造函数，初始化父类对象的vptr，此时vptr指向父类的vtbale，当执行子类的构造函数时，子类对象的vptr被初始化，指向子类的vtbale


