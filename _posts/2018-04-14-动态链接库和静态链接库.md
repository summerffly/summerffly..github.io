---
layout: post
title: 动态链接库和静态链接库
date: 2018-04-14
tags: 程序猿的自我修养
---

　现实中实现一个软件项目，总是要依赖很多成熟的库，就像造一辆车，不可能也没有必要从轮子开始造车，直接使用别人现成的轮子，这样我们可以把精力和时间放在项目中最核心的部分，库是软件项目中最重要的基石之一，本篇主要讨论什么是库，动态库和静态库的区别，以及如何在Windows和Linux编程中使用库，开始之前先推荐一本书《程序员的自我修养——链接、装载与库》，深入阐述了代码最终是怎么成为可执行程序

### 什么是库？

　库的本质非常简单，其实就是写好的、可供调用的代码，现实中每个程序都要依赖很多基础的底层库，不可能每个项目的代码都从零开始，因此库的存在意义非常重要

　从实现上看，库是一种可执行代码的二进制形式，可以被操作系统载入内存执行，根据链接阶段的时间不同，库可以分为两种：静态链接库（.a、.lib）和动态链接库（.so、.dll）

![](/images/posts/Windows/Lib-01.png)

### 为什么要使用库？

- **封装代码，避免剽窃**

	在项目中，常常需要开放接口给其他合作者或者客户调用，很多情况下，需要开放的代码中可能包含了自己的核心专利技术，我们并不想公开这部分代码，我们可以将代码封装成为库，这样对方可以方便调用我们的接口，但又不暴露自己的代码

- **便于程序员合作**

	库真正实现了跨语言，对系统以及应用程序来说，哪种语言生成的库是没有区别的，在一个大型项目中，不同的程序员负责不同的部分，可能大家使用的语言也不相同，合作编译就成了一个大问题，有了库，大家只需要把自己的部分封装成库，供主程序调用

- **提高程序可维护性**

	这个有点同样主要针对动态链接库，因为应用程序需要时才将动态链接库载入内存，使用动态链接库就让程序的可维护性变得很高，如果想要升级某一个模块，不再需要去重新改主程序的代码，或者重新编译打包程序，只需要升级替换对应模块的动态链接库就可以了

### 静态链接库和动态链接库的区别

　根据链接阶段的时间不同，库可以分为两种：静态链接库（.a、.lib）和动态链接库（.so、.dll）

　静态链接库采用静态链接方式，在链接阶段，会将汇编生成的目标文件.o与静态链接库一起链接打包到可执行文件中，既然静态链接库可以和目标文件.o一起链接为可执行文件，说明静态链接库可以和目标文件.o格式很类似，其实本质上静态链接库就是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件

　然而静态链接库却对于空间和时间存在着两个“浪费”问题：

- **空间浪费问题：**如果2000个文件都链接了某一个静态链接库，那么这个静态链接库在内存中就会有2000份copy，浪费了不必要的内存空间

- **时间浪费问题：**如果应用程序链接的一个静态链接库哪怕只做了一个小小的改动，也要对应用程序的整个工程重新编译、链接，浪费了不必要的等待时间

![](/images/posts/Windows/Lib-02.png)

　静态链接库的这两个“浪费”问题，在动态链接库上得到了完美的解决，动态链接库在程序编译时并不会被链接到可执行文件中，而是在可执行程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题，对于动态链接库的更新改动，也只需要替换动态链接库文件即可，不需要对整个工程全部重新编译，规避了时间浪费问题

![](/images/posts/Windows/Lib-03.png)

### Windows下使用静态链接库(.lib)和动态链接库(.dll)

- **创建静态链接库（.lib）**

	创建Win32控制台程序时，勾选 “Static library(.lib)” 类型；或者打开工程“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “General(常规)”，将“Configuration Type”设置为“Static library(.lib)”；
	
	Build项目就可以生成静态链接库（.lib）

- **使用静态链接库（.lib）**

	在VS中使用静态库，需要在项目工程属性中添加这个Lib文件的头文件目录和Lib文件目录，最后添加Lib文件：
	
	(1) 打开“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “Linker(链接器)” -> “General(常规)”，在“Additional Include Directories(附加包含目录)”中添加这个Lib文件的头文件目录；

	(2) 打开“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “Linker(链接器)” -> “General(常规)”，在“Link Library Dependencies(附加库目录)”中添加这个Lib文件目录；

	(3) 打开“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “Linker(链接器)” -> “Input(输入)”，在“Additional Dependencies(附加依赖项)”中直接添加静态链接库（.lib）；
	
	(4) 然后在代码中引用以下两行代码中的任意一行，就可以使用静态链接库
	
	```
	#include "StaticLibrary.h"
	#pragma comment(Lib, "StaticLibPath")
	```
	
	VS在在查找静态链接库（.lib）时有一个先后的顺序：先查找指定的附加依赖项，如果没有找到，就从附加库目录中搜索，附加库目录的搜索花费的时间回比较久
	
- **创建动态链接库（.dll）**

	Windows系统中，dll其实和exe是几乎完全一样的，唯一的不一样就是exe的入口函数是WinMain()函数（console程序是main函数），而dll是DllMain()函数，其他完全一样，所以也可以把dll当成不能自己运行的exe
	
	VS中创建动态链接库（.dll）会稍微麻烦一些
	
	(1) 创建Win32控制台程序时，勾选 “Dynamic library(.dll)” 类型；或者打开工程“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “General(常规)”，将“Configuration Type”设置为“Dynamic library(.dll)”；
	
	(2) 需要一个DllMain函数做出初始化的入口（创建Win32控制台程序时，勾选 “Dynamic library(.dll)” 类型，会自动生成这个文件）

	```
	// dllmain.cpp : 定义 DLL 应用程序的入口点。
	#include "stdafx.h"
 
	BOOL APIENTRY DllMain( HMODULE hModule,
                       	DWORD  ul_reason_for_call,
                       	LPVOID lpReserved
                     	 )
	{
	　switch (ul_reason_for_call)
	　{
	　　case DLL_PROCESS_ATTACH:
	　　case DLL_THREAD_ATTACH:
	　　case DLL_THREAD_DETACH:
	　　case DLL_PROCESS_DETACH:
    　　break;
	　}
	　return TRUE;
	}
	```

	(3) 在导出函数的声明时，extern “C”表示要按照C语言的方式编译该函数，防止在C++工程中编译出现函数名错误，因为C++中有函数重载，所以函数名编译后可能会出现Print@1的形式；而且这样也可以让C调用C++的动态链接库；__declspec(dllexport)表示下来的函数是dll的导出函数接口

	```
	/*DynamicLibrary.h头文件*/
	 
	extern "C" __declspec(dllexport) void Print(void);
	```
	
	Build项目即可生成动态链接库（.dll）
	
	查看生成的动态链接库（.dll）文件，发现同时产生了一个.lib文件，这个.lib文件其实是动态链接库对应的动态导入库，静态链接库同时包含了实际执行代码和地址符号表，动态导入库只包含了地址符号表，实际的执行代码还是位于动态链接库中，动态导入库确保程序找到对应函数的一些基本地址信息

- **隐式调用动态链接库（.dll）**

	隐式调用动态链接库需要使用上面介绍的动态导入库，动态导入库的调用方法与静态链接库完全一致，唯一的区别就是使用动态导入库编译出来的程序，运行时需要其对应的Dll文件（在同一目录下）

- **显示调用动态链接库（.dll）**

	显示调用动态链接库有以下步骤：
	
	(1) 加载dll文件;
	
	(2) 取得文件内相应函数的指针;
	
	(3) 使用函数;
	
	(4) 释放dll句柄;
	
	```
	// 声明函数指针类型
	typedef int(__stdcall *fntest)(char *test);
	
	// 将dll加载到内存中，用句柄表示
	HINSTANSE hLib = ::LoadLibrary(_T("DynamicLibrary.dll"));
	if(NULL == hLib)
	{
	　// error
	}
	fntest fnsa;
	
	// 根据dll的句柄得到相应函数的指针
	fnsa = (fntest)GetProcAddress(hLib,"Print");
	
	...
	
	// 使用完后，释放dll句柄
	::FreeLibrary(hLib);
	```

