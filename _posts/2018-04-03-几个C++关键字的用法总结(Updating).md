---
layout: post
title: 几个C++关键字的用法总结(Updating)
date: 2018-04-03
tags: C++
---

### 作用域运算符::

　作用域运算符::是运算符中等级最高的，可以分成三种：

- **全局作用域符：**

　当全局变量在某个局部作用中与其中某个局部变量重名，那么就可以用全局作用域符::来区分
	
	```
	int x;   // 全局变量 
	void func()
	{ 
	　int x;   // 局部变量 
	　x = x + x;   // 局部变量，代码块中局部变量会覆盖全局变量 
	　::x = ::x + x;   // 前两个x为全局变量，最后的x为局部变量 
	}
	```

- **类作用域符：**

　为了避免不同的类有名称相同的成员，可以用类作用域符进行区分，类作用域符前面是类的名称，后面是该类的成员名称

	```
	class A
	{
	public:
	　void func();
	}
	
	class B
	{
	public:
	　void func();
	}
	
	void A::func()
	{
	　// ...
	}
	
	void B::func()
	{
	　// ...
	}
	```

- **命名空间作用域符：**

　命名空间作用域符可以区分不同命名空间中的成员，命名空间作用域符前面是命名空间的名称，后面是该命名空间的成员名称

	```
	#include <iostream>
	using namespace std;
	
	namespace A
	{
	　int x = 1;
	　
	　void fun()
	　{
	　　cout << "A" << endl;
	　}
	}
	
	namespace B
	{
	　int x = 2;
	　
	　void fun()
	　{
	　　cout << "B" << endl;
	　}
	　
	　void fun2()
	　{
	　　cout << "BB" << endl;
	　}
	}
	
	int main()
	{
	　cout << A::x << endl;
	　cout << B::x << endl;
	
	　using namespace B;
	
	　A::fun();
	　fun();
	　fun2();
	　
	　return 0;
	}
	```

### 关键字extern

　C++支持分离式编译机制，一个完整的程序或项目可以分割为若干个.cpp源文件，每个.cpp源文件单独编译生成.obj目标文件，最后将所有.obj目标文件链接成一个单一的可执行文件，如果一个.cpp源文件要使用另一个.cpp源文件定义的变量，应该如何调用？ —— C++中解决方法是将 `变量声明` 与 `变量定义` 分离：

　`变量声明` 规定了变量的类型和名字，但仅仅只是告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存，使得名字为本程序文件所知道，比如一个文件如果想使用在另外一个文件中定义的变量，则必须包含对那个变量名字的声明，关键字extern就被用来实现 `变量声明`

　`变量定义` 同样规定了变量的类型和名字，不同于 `变量声明` 的是，`变量定义` 还会给变量申请存储空间，还可能给变量赋予一个初始值，如果多个文件中都定义了同一个变量，编译时会产生变量重定义冲突错误

	```
	extern int i;   // 变量声明
	int j;   // 变量定义
	
	// 需要注意，任何一个显式初始化的声明都将成为定义，而不管有没有extern
	extern double pi = 3.1415926;
	```

　关键字extern主要有以下三种使用方法：

- **引用同一个文件中的变量**

```
#include <stdio.h>

int func();

int main()
{
　func();
　extern int num;   // 引用同一个文件中的变量
　printf("%d", num);
　
　return 0;
}

int num = 3;

int func()
{
　printf("%d\n",num);
}
```

- **引用另一个文件中的变量**

```
// main.cpp

#include <stdio.h>

int main()
{
　extern int num;   // 引用另一个文件中的变量
　printf("%d",num);
　
　return 0;
}
```

```
// branch.cpp

#include <stdio.h>

int num = 5;
```

- **引用另一个文件中的函数**

```
// main.cpp

#include <stdio.h>

int main()
{
　extern void func();   // 引用另一个文件中的函数
　func();
　
　return 0;
}
```

```
// branch.cpp

#include <stdio.h>

void func()
{
　printf("func");
}
```

### 关键字const

- const定义常量，不能被修改；

```
const int a;
```

- const修饰函数参数，防止被意外修改；

```
void func(const int a);
```

- const修饰函数返回值，则返回值不能被直接修改，且只能赋值给const修饰的同类变量；

```
const int x = const int func(const int a);
```

- const修饰类成员变量，只能在定义的时候进行初始化，并且在程序的执行过程中不能被再次赋值；

- const修饰类成员函数，放在类成员函数声明之后，保证不会修改该对象的成员变量

任何不会修改类成员变量的类成员函数都应该使用const修饰，const成员函数不能调用非const成员函数

```
void fun(int val) const
```

### 关键字static（面向过程）

　关键字static的作用主要可以分为两方面，一方面是面向过程，另一方面是面向对象，先介绍面向过程：

- **静态全局变量**

	在全局变量前加上关键字static，该变量就被定义为静态全局变量，静态全局变量在全局/静态存储区初始化，作用域仅限于定义的文件，具有内部链接性

- **静态局部变量**

	在代码块中定义的变量前加上关键字static，该变量就被定义为静态局部变量，他始终驻留在全局/静态存储区，直到程序运行结束

- **静态函数**

	静态函数的声明方法也是在函数前加上关键字static，作用域仅限于定义的文件，不能被其他文件引用，不会发生冲突

### 关键字static（面向对象）

- **静态成员变量**

	对于非静态成员变量，每个类对象都有自己的拷贝，而静态成员变量只有一份拷贝，存在于全局/静态存储区，由该类型的所有对象共享，静态成员变量定义时要分配空间，所以不能在类声明中定义，只能在类外定义

- **静态成员函数**

	普通成员函数一般都隐藏了一个this指针，this指针指向类对象本身，因为普通成员函数总是具体的属于某个类的具体对象的，而静态成员函数不具有this指针，因此他无法访问属于类对象的非静态成员变量，也无法访问非静态成员函数


